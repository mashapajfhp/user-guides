name: Validate Feature Guide

on:
  push:
    paths:
      - '**/validation/validation-payload.json'
  workflow_dispatch:
    inputs:
      feature_folder:
        description: 'Feature folder to validate (e.g., overtime/v1)'
        required: true
      debug_mode:
        description: 'Enable debug logging'
        required: false
        default: 'false'

env:
  PLAYWRIGHT_MCP_SERVER: "@executeautomation/playwright-mcp-server"
  NODE_VERSION: "20"

jobs:
  validate:
    runs-on: [self-hosted, validation]
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          persist-credentials: false

      - name: Detect validation payload
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.feature_folder }}" ]; then
            FOLDER="${{ github.event.inputs.feature_folder }}"
          else
            CHANGED_FILE=$(git diff --name-only HEAD~1 HEAD | grep 'validation/validation-payload.json' | head -1)
            if [ -n "$CHANGED_FILE" ]; then
              FOLDER=$(echo "$CHANGED_FILE" | sed 's|/validation/.*||')
            fi
          fi

          if [ -z "$FOLDER" ]; then
            echo "No validation request found"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          PAYLOAD_FILE="$GITHUB_WORKSPACE/$FOLDER/validation/validation-payload.json"
          if [ ! -f "$PAYLOAD_FILE" ]; then
            echo "Payload file not found: $PAYLOAD_FILE"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "folder=$FOLDER" >> $GITHUB_OUTPUT
          echo "payload_file=$PAYLOAD_FILE" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

          # Extract feature info (supports object format with .feature_info)
          FEATURE_NAME=$(jq -r '.feature_info.feature_name // .metadata.feature_name // "unknown"' "$PAYLOAD_FILE")
          FEATURE_SLUG=$(jq -r '.feature_info.feature_slug // .metadata.feature_slug // "unknown"' "$PAYLOAD_FILE")
          VERSION=$(jq -r '.feature_info.next_version // .metadata.version // "v1"' "$PAYLOAD_FILE")

          echo "feature_name=$FEATURE_NAME" >> $GITHUB_OUTPUT
          echo "feature_slug=$FEATURE_SLUG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup directories
        id: dirs
        if: steps.detect.outputs.skip != 'true'
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          BASE_DIR="$GITHUB_WORKSPACE/$FOLDER/validation"

          # Create all output directories
          mkdir -p "$BASE_DIR/screenshots"
          mkdir -p "$BASE_DIR/results"
          mkdir -p "$BASE_DIR/logs"
          mkdir -p "$BASE_DIR/artifacts"

          # Output paths for later steps
          echo "base_dir=$BASE_DIR" >> $GITHUB_OUTPUT
          echo "screenshots_dir=$BASE_DIR/screenshots" >> $GITHUB_OUTPUT
          echo "results_dir=$BASE_DIR/results" >> $GITHUB_OUTPUT
          echo "logs_dir=$BASE_DIR/logs" >> $GITHUB_OUTPUT
          echo "result_file=$BASE_DIR/result.json" >> $GITHUB_OUTPUT
          echo "report_file=$BASE_DIR/report.md" >> $GITHUB_OUTPUT
          echo "log_file=$BASE_DIR/logs/validation.log" >> $GITHUB_OUTPUT

          echo "Output directories created:"
          echo "  Screenshots: $BASE_DIR/screenshots"
          echo "  Results: $BASE_DIR/results"
          echo "  Logs: $BASE_DIR/logs"
          echo "  Artifacts: $BASE_DIR/artifacts"

      - name: Setup Node.js
        if: steps.detect.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Playwright MCP
        if: steps.detect.outputs.skip != 'true'
        run: npm install -g ${{ env.PLAYWRIGHT_MCP_SERVER }}

      - name: Run Playwright Validation
        if: steps.detect.outputs.skip != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
          APP_USERNAME: ${{ secrets.APP_USERNAME }}
          APP_PASSWORD: ${{ secrets.APP_PASSWORD }}
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          PAYLOAD_FILE="${{ steps.detect.outputs.payload_file }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"
          SCREENSHOTS_DIR="${{ steps.dirs.outputs.screenshots_dir }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"
          LOG_FILE="${{ steps.dirs.outputs.log_file }}"

          # Create the prompt file
          PROMPT_FILE=$(mktemp)
          cat > "$PROMPT_FILE" << 'PROMPT_HEADER'
          You are a QA validation agent using Playwright MCP to explore and validate a feature in the Bayzat HR application.
          Your output will be used to generate user guides, so document EVERYTHING you see and experience.

          ## YOUR MISSION
          Freely explore the feature described in the payload below. Your goal is to:
          1. Successfully log in to the application
          2. Navigate to the feature location
          3. Explore each task/workflow described
          4. Take screenshots as evidence
          5. Document EVERYTHING - what works, what made it work, what doesn't work
          6. Capture the full user journey narrative for each screen

          ## CRITICAL FIRST STEPS

          ### Step 1: Browser Setup - Set Large Viewport
          BEFORE doing anything else, set a large viewport to see all UI elements:

          Call browser_resize with width=1280 and height=900

          This ensures:
          - Full sidebar is visible (including Settings at bottom)
          - No UI elements are cut off
          - Consistent screenshots across runs

          **IMPORTANT: Stay within the application!**
          - Only navigate within app.bayzat.com
          - Do NOT click links that go to external sites (zendesk, help center, etc.)
          - Do NOT open new tabs to external URLs
          - If you accidentally navigate away, use browser_navigate_back to return

          **CRITICAL: Navigate by CLICKING, not by URL!**
          - NEVER use browser_navigate to go to internal pages (e.g., /payroll, /time, /leave-salary)
          - ALWAYS click on menu items, sidebar links, and navigation elements to move between pages
          - The only time to use browser_navigate is for the initial login page
          - Many routes return 404 when accessed directly - they MUST be reached via UI clicks
          - Use the sidebar menu on the left to navigate to different sections
          - If a menu item has a submenu, click the parent first, then click the child item

          ### Step 2: Login
          1. Call browser_navigate with url from CREDENTIALS section (Base URL)
          2. Call browser_resize with width=1280 and height=900
          3. Call browser_wait_for with time=3 (wait for page to fully load)
          4. Call browser_snapshot to see the page structure
          5. If you see textbox fields for "Email address" and "Password":
             a. Use browser_type on the Email textbox (find the ref in snapshot)
             b. Use browser_type on the Password textbox
             c. Use browser_click on the "Log in" button
          6. If browser_type fails, use this JavaScript approach via browser_evaluate:
             () => {
               const email = document.querySelector('input[placeholder="Email address"]');
               const pass = document.querySelector('input[placeholder="Password"]');
               if (email && pass) {
                 email.value = 'USERNAME_PLACEHOLDER';
                 email.dispatchEvent(new Event('input', { bubbles: true }));
                 pass.value = 'PASSWORD_PLACEHOLDER';
                 pass.dispatchEvent(new Event('input', { bubbles: true }));
                 const btn = document.querySelector('button[type="submit"]');
                 if (btn) btn.click();
                 return 'Login submitted';
               }
               return 'Form not found';
             }
             (Replace USERNAME_PLACEHOLDER and PASSWORD_PLACEHOLDER with actual values from CREDENTIALS)
          7. Call browser_wait_for with time=5 (wait for dashboard)
          8. Call browser_snapshot to verify you're on the dashboard (should see "Home", "Company", etc. in sidebar)

          ### Step 3: Dismiss ALL onboarding/tour popovers

          Bayzat uses MUI Tooltip-based tours with specific data-external-id attributes.

          **A) Set localStorage flags to mark ALL tours complete (MOST RELIABLE)**
          Call browser_evaluate with function:
          () => { const tourKeys = { '_bayzat_app_new_web_ia_tour': '{"value":5}', '_bayzat_app_ai-reports-tooltip-visible': '{"value":false}', '_bayzat_app_space_creation_walkthrough': '5', '_bayzat_app_employee-ticket-list-library-intro-dialog': '{"value":true}', '_bayzat_app_setup_categories_walkthrough_step': '{"value":99}', '_bayzat_app_list_library_walkthrough_step': '{"value":99}' }; Object.entries(tourKeys).forEach(([k,v]) => localStorage.setItem(k,v)); return 'Tour localStorage flags set: ' + Object.keys(tourKeys).join(', '); }

          **B) Wait for any tours to render**
          Call browser_wait_for with time=2

          **C) Click dismiss buttons using data-external-id selectors**
          Call browser_evaluate with function:
          () => { const dismissed = []; const selectors = ['[data-external-id="close-button"]', '[data-external-id="confirm-button"]', '[data-external-id="next-button"]']; selectors.forEach(sel => { document.querySelectorAll(sel).forEach(btn => { try { btn.click(); dismissed.push(sel); } catch(e) {} }); }); document.querySelectorAll('[role="tooltip"]').forEach(t => t.remove()); return { dismissed, count: dismissed.length }; }

          **D) Verify dismissal**
          Call browser_wait_for with time=1, then call browser_snapshot.
          If any [role="tooltip"] with walkthrough content remains visible, repeat step C once more.

          **E) Continue to feature exploration**
          After dismissal, proceed to Step 4 without taking dismissal screenshots (saves time).

          ### Step 4: Explore the Feature
          Based on the payload's "where_to_go" and "what_to_do" sections:
          1. Navigate to the feature location
          2. For each task in "what_to_do", try to follow the steps
          3. Take screenshots at key points
          4. Note any issues or blockers you encounter

          ### Step 5: DEEP UI EXPLORATION (CRITICAL)
          Thoroughly explore ALL areas of the UI related to this feature:

          1. **Navigate every tab, section, and sub-menu** related to the feature
          2. **Click on every button, link, and interactive element** to see what happens
          3. **Open all dropdowns, modals, and expandable sections**
          4. **Test form fields** - what options are available, what validations exist

          ### Step 6: SCREEN DOCUMENTATION PROTOCOL
          For EVERY screen/page you visit, document:

          **A. All Visible Elements:**
          - Page title and breadcrumbs
          - Navigation elements (tabs, sidebar items, menu items)
          - Headers and section titles
          - Buttons (with their labels and states - enabled/disabled)
          - Links and their destinations
          - Form fields (text inputs, dropdowns, checkboxes, radio buttons, date pickers)
          - Tables (column headers, row data patterns, pagination)
          - Cards and info panels
          - Status indicators and badges
          - Icons and their meanings
          - Empty states and placeholder text

          **B. Interactive Element Exploration:**
          For each button/link, document:
          - What it's labeled
          - Whether it's clickable or disabled
          - What happens when clicked (modal opens, page navigates, action executes)
          - Any confirmation dialogs that appear

          **C. Form Field Documentation:**
          For each form field:
          - Field label and placeholder text
          - Whether it's required or optional
          - Input type (text, number, date, dropdown, etc.)
          - Available options (for dropdowns/selects)
          - Validation rules (when do errors appear?)
          - Default/pre-filled values
          - Help text or tooltips

          **D. State Documentation:**
          - What changes when data exists vs. empty state
          - Loading states and spinners
          - Success/error messages
          - Permission-based visibility (what might be hidden for other roles)

          ## OUTPUT FORMAT - MANDATORY JSON RESPONSE

          **CRITICAL: You MUST output a JSON result wrapped in ```json code blocks.**
          This JSON is automatically extracted and used for user guide generation.
          Without proper JSON output, the workflow will fail.

          At the end of your exploration, output the JSON result with this EXACT structure:
          {
            "validation_status": "completed" or "partial" or "blocked",
            "login_success": true/false,
            "feature_accessible": true/false,
            "feature_info": {
              "name": "Feature Name",
              "slug": "feature-slug",
              "category": "category",
              "url": "/path/to/feature"
            },
            "exploration_journey": [
              {
                "screen_name": "Screen/Page Name",
                "url": "/path/to/screen",
                "screenshot": "screenshot-name.png",
                "what_i_went_through": "Narrative of navigation path to reach this screen",
                "what_i_came_across": "What elements and sections were present on the screen",
                "what_i_saw": {
                  "page_structure": "Description of layout and main sections",
                  "visible_elements": ["List of all visible UI elements"],
                  "data_displayed": "What data/information was shown",
                  "empty_states": "Any empty states or placeholder messages"
                },
                "actions_i_performed": [
                  {
                    "action": "What I did (clicked, typed, selected, etc.)",
                    "target": "Which element I interacted with",
                    "result": "What happened after the action",
                    "screenshot_after": "screenshot-after-action.png"
                  }
                ],
                "results_i_got": {
                  "success_outcomes": ["What worked successfully"],
                  "error_outcomes": ["Any errors or issues encountered"],
                  "unexpected_behaviors": ["Anything surprising or unexpected"]
                }
              }
            ],
            "tasks_explored": [
              {
                "task": "task name",
                "status": "completed" or "partial" or "blocked",
                "notes": "what you observed",
                "screenshots": ["screenshot1.png"]
              }
            ],
            "full_behavior_catalog": {
              "buttons": [
                {
                  "label": "Button text",
                  "location": "Where on the screen",
                  "state": "enabled/disabled",
                  "action_result": "What happens when clicked"
                }
              ],
              "dropdowns": [
                {
                  "label": "Dropdown label",
                  "options": ["List of available options"],
                  "default_value": "Pre-selected value if any"
                }
              ],
              "form_fields": [
                {
                  "label": "Field label",
                  "type": "text/number/date/dropdown/checkbox/etc",
                  "required": true/false,
                  "placeholder": "Placeholder text",
                  "validation": "Validation rule if any",
                  "error_message": "Error shown when invalid"
                }
              ],
              "tabs": [
                {
                  "label": "Tab name",
                  "content_summary": "What the tab contains",
                  "item_count": "Number of items if applicable"
                }
              ],
              "modals_dialogs": [
                {
                  "trigger": "What opens this modal",
                  "title": "Modal title",
                  "content": "What's inside the modal",
                  "actions": ["Available action buttons"]
                }
              ],
              "tables": [
                {
                  "location": "Where the table is",
                  "columns": ["Column headers"],
                  "row_actions": ["Actions available per row"],
                  "pagination": "Pagination details if any"
                }
              ],
              "filters": [
                {
                  "filter_name": "Name of filter",
                  "filter_type": "dropdown/date/text/range",
                  "options": ["Available filter options"]
                }
              ],
              "notifications_alerts": [
                {
                  "type": "success/error/warning/info",
                  "trigger": "When it appears",
                  "message": "The message content"
                }
              ]
            },
            "ui_behaviors_documented": {
              "disabled_states": [
                {"element": "element name", "condition": "when/why it's disabled"}
              ],
              "conditional_logic": [
                {"trigger": "what action", "result": "what appears/changes"}
              ],
              "progressive_disclosure": [
                {"action": "user action", "reveals": "what new content appears"}
              ],
              "required_fields": ["list of required fields"],
              "optional_fields": ["list of optional fields"],
              "default_values": [
                {"field": "field name", "default": "default value"}
              ],
              "validation_rules": [
                {"field": "field name", "rule": "validation rule", "error_message": "message shown"}
              ],
              "tooltips_help_text": [
                {"element": "element name", "text": "tooltip/help content"}
              ]
            },
            "what_works": [
              {
                "feature_aspect": "What functionality works",
                "description": "How it works",
                "user_benefit": "Why this is good for users"
              }
            ],
            "what_made_it_work": [
              {
                "success_factor": "What enabled the success",
                "prerequisites": "What needed to be in place",
                "steps_taken": ["Steps that led to success"]
              }
            ],
            "whats_not_working": [
              {
                "issue": "What doesn't work or has problems",
                "symptoms": "How the issue manifests",
                "impact": "Effect on user experience",
                "possible_cause": "Suspected reason if identifiable"
              }
            ],
            "ui_sections_explored": ["list of all sections/tabs/pages visited"],
            "issues_found": ["list of any issues"],
            "known_issues_validated": [
              {
                "issue": "Issue from payload",
                "status": "confirmed/not_validated/not_reproducible",
                "evidence": "What confirmed or disproved it"
              }
            ],
            "screenshots_taken": 0,
            "validation_timestamp": "ISO timestamp",
            "recommendations_for_user_guide": [
              "Specific recommendations for what to include in the user guide based on exploration"
            ],
            "summary": "Comprehensive summary of the entire exploration"
          }

          PROMPT_HEADER

          cat >> "$PROMPT_FILE" << EOF

          ## CREDENTIALS
          - Base URL: $APP_BASE_URL
          - Username: $APP_USERNAME
          - Password: $APP_PASSWORD

          ## SCREENSHOTS DIRECTORY
          Save all screenshots to: $SCREENSHOTS_DIR

          ## FEATURE PAYLOAD
          $(cat "$PAYLOAD_FILE")

          ## BEGIN EXPLORATION
          Start by setting up the browser, then login, then explore the feature.

          **CRITICAL: You have LIMITED turns (150 max). Be efficient!**
          - Focus on the main feature workflows, don't explore unrelated areas
          - After exploring 3-5 key screens, OUTPUT YOUR JSON RESULT
          - If you're at turn 100+, STOP exploring and output the JSON immediately
          - ALWAYS end with the complete JSON result - this is REQUIRED
          - An incomplete exploration WITH JSON output is better than complete exploration WITHOUT JSON

          ## FINAL OUTPUT REMINDER - DO NOT SKIP

          When you finish exploring, you MUST output a JSON block like this:

          \`\`\`json
          {
            "validation_status": "completed",
            "login_success": true,
            "feature_accessible": true,
            "feature_info": { ... },
            "exploration_journey": [ ... ],
            "tasks_explored": [ ... ],
            "what_works": [ ... ],
            "whats_not_working": [ ... ],
            "screenshots_taken": 16,
            "summary": "Your comprehensive summary here"
          }
          \`\`\`

          **The JSON block is MANDATORY. Without it, the workflow fails and your work is lost.**
          EOF

          echo "Starting Playwright validation for: $FEATURE_NAME"
          echo "============================================"

          # Create MCP config file (avoid shell escaping issues)
          MCP_CONFIG_FILE=$(mktemp)
          cat > "$MCP_CONFIG_FILE" << 'MCPCONFIG'
          {
            "mcpServers": {
              "playwright": {
                "command": "npx",
                "args": ["@executeautomation/playwright-mcp-server"],
                "env": {
                  "HEADLESS": "false",
                  "BROWSER": "chrome",
                  "VIEWPORT_WIDTH": "1280",
                  "VIEWPORT_HEIGHT": "900"
                }
              }
            }
          }
          MCPCONFIG

          # Run Claude Code with Playwright MCP (pipe prompt via stdin)
          cat "$PROMPT_FILE" | npx @anthropic-ai/claude-code@latest \
            --print \
            --dangerously-skip-permissions \
            --max-turns 300 \
            --mcp-config "$MCP_CONFIG_FILE" \
            2>&1 | tee "$RESULT_FILE.raw"

          # Extract JSON result from output using proper balanced brace parsing
          if [ -f "$RESULT_FILE.raw" ]; then
            PYEXTRACT_SCRIPT=$(mktemp)
            cat > "$PYEXTRACT_SCRIPT" << 'PYEOF'
          import sys
          import re
          import json

          raw_file = sys.argv[1]
          out_file = sys.argv[2]

          with open(raw_file, 'r', errors='ignore') as f:
              content = f.read()

          def extract_json_objects(text):
              """Extract JSON objects using balanced brace matching."""
              results = []
              i = 0
              while i < len(text):
                  if text[i] == '{':
                      depth = 0
                      start = i
                      in_string = False
                      escape_next = False
                      while i < len(text):
                          char = text[i]
                          if escape_next:
                              escape_next = False
                          elif char == '\\' and in_string:
                              escape_next = True
                          elif char == '"' and not escape_next:
                              in_string = not in_string
                          elif not in_string:
                              if char == '{':
                                  depth += 1
                              elif char == '}':
                                  depth -= 1
                                  if depth == 0:
                                      candidate = text[start:i+1]
                                      try:
                                          obj = json.loads(candidate)
                                          if isinstance(obj, dict) and any(k in obj for k in ['validation_status', 'exploration_journey', 'feature_info', 'login_success']):
                                              results.append((len(candidate), obj))
                                      except json.JSONDecodeError:
                                          pass
                                      break
                          i += 1
                  i += 1
              return results

          json_blocks = re.findall(r'```json\s*([\s\S]*?)\s*```', content)
          for block in reversed(json_blocks):
              try:
                  parsed = json.loads(block)
                  if isinstance(parsed, dict) and any(k in parsed for k in ['validation_status', 'exploration_journey', 'feature_info']):
                      with open(out_file, 'w') as f:
                          json.dump(parsed, f, indent=2)
                      print(f"Extracted JSON from code block ({len(block)} chars)")
                      sys.exit(0)
              except json.JSONDecodeError:
                  continue

          json_objects = extract_json_objects(content)
          if json_objects:
              largest = max(json_objects, key=lambda x: x[0])
              with open(out_file, 'w') as f:
                  json.dump(largest[1], f, indent=2)
              print(f"Extracted JSON using brace matching ({largest[0]} chars)")
              sys.exit(0)

          all_objects = []
          i = 0
          while i < len(content):
              if content[i] == '{':
                  for j in range(len(content) - 1, i, -1):
                      if content[j] == '}':
                          try:
                              candidate = content[i:j+1]
                              obj = json.loads(candidate)
                              if isinstance(obj, dict) and len(obj) > 3:
                                  all_objects.append((len(candidate), obj))
                              break
                          except:
                              continue
              i += 1

          if all_objects:
              largest = max(all_objects, key=lambda x: x[0])
              with open(out_file, 'w') as f:
                  json.dump(largest[1], f, indent=2)
              print(f"Extracted JSON using fallback method ({largest[0]} chars)")
              sys.exit(0)

          with open(out_file, 'w') as f:
              json.dump({
                  "error": "Could not extract valid JSON from output",
                  "raw_length": len(content),
                  "json_blocks_found": len(json_blocks),
                  "hint": "The Claude output may not have included a properly formatted JSON result"
              }, f, indent=2)
          print("WARNING: Could not extract JSON, wrote error file")
          PYEOF
            python3 "$PYEXTRACT_SCRIPT" "$RESULT_FILE.raw" "$RESULT_FILE"
            rm -f "$PYEXTRACT_SCRIPT"
          fi

          # Cleanup temp files
          rm -f "$MCP_CONFIG_FILE" "$PROMPT_FILE"

          echo "============================================"
          echo "Validation complete"

      - name: Merge Payload Data into Result
        if: steps.detect.outputs.skip != 'true'
        run: |
          PAYLOAD_FILE="${{ steps.detect.outputs.payload_file }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"

          echo "Merging payload data into result.json..."

          # Merge what_to_watch_out_for, what_to_do, feature_info from payload into result
          PYMERGE_SCRIPT=$(mktemp)
          cat > "$PYMERGE_SCRIPT" << 'PYEOF'
          import sys
          import json

          payload_file = sys.argv[1]
          result_file = sys.argv[2]

          try:
              with open(payload_file, 'r') as f:
                  payload_data = json.load(f)
                  if isinstance(payload_data, list) and len(payload_data) > 0:
                      payload_data = payload_data[0]
          except Exception as e:
              print(f"Warning: Could not load payload: {e}")
              payload_data = {}

          try:
              with open(result_file, 'r') as f:
                  result_data = json.load(f)
          except Exception as e:
              print(f"Warning: Could not load result: {e}")
              result_data = {}

          playwright_context = payload_data.get('playwright_context', {})

          what_to_watch_out_for = (
              playwright_context.get('what_to_watch_out_for') or
              payload_data.get('what_to_watch_out_for') or
              []
          )

          what_to_do = (
              playwright_context.get('what_to_do') or
              payload_data.get('what_to_do') or
              []
          )

          feature_info = (
              payload_data.get('feature_info') or
              playwright_context.get('feature_metadata') or
              {}
          )

          detected_integrations = (
              payload_data.get('detected_integrations') or
              playwright_context.get('detected_integrations') or
              {}
          )

          result_data['payload_context'] = {
              'what_to_watch_out_for': what_to_watch_out_for,
              'what_to_do': what_to_do,
              'feature_info': feature_info,
              'detected_integrations': detected_integrations,
              'limitations_count': len(what_to_watch_out_for),
              'tasks_count': len(what_to_do)
          }

          if what_to_watch_out_for and 'what_to_watch_out_for' not in result_data:
              result_data['what_to_watch_out_for'] = what_to_watch_out_for

          if what_to_do and 'what_to_do' not in result_data:
              result_data['what_to_do'] = what_to_do

          with open(result_file, 'w') as f:
              json.dump(result_data, f, indent=2)

          print(f"Merged payload data into result:")
          print(f"  - what_to_watch_out_for: {len(what_to_watch_out_for)} items")
          print(f"  - what_to_do: {len(what_to_do)} tasks")
          print(f"  - feature_info: {feature_info.get('feature_name', 'unknown')}")
          PYEOF
          python3 "$PYMERGE_SCRIPT" "$PAYLOAD_FILE" "$RESULT_FILE"
          rm -f "$PYMERGE_SCRIPT"

      - name: Generate Report
        if: steps.detect.outputs.skip != 'true'
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"
          FEATURE_SLUG="${{ steps.detect.outputs.feature_slug }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"
          REPORT_FILE="${{ steps.dirs.outputs.report_file }}"
          SCREENSHOTS_DIR="${{ steps.dirs.outputs.screenshots_dir }}"

          # Start report - write header
          {
            echo "# Validation Report: ${FEATURE_NAME}"
            echo ""
            echo "**Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "**Run ID**: ${{ github.run_id }}"
            echo ""
            echo "## Result"
            echo ""
            echo '```json'
            cat "$RESULT_FILE" 2>/dev/null || echo '{"error": "No result file generated"}'
            echo '```'
            echo ""
            echo "## Screenshots"
            echo ""
          } > "$REPORT_FILE"

          # Add screenshots as markdown image links
          if [ -d "$SCREENSHOTS_DIR" ] && [ "$(ls -A "$SCREENSHOTS_DIR" 2>/dev/null)" ]; then
            SCREENSHOT_COUNT=0
            for img in "$SCREENSHOTS_DIR"/*.png; do
              if [ -f "$img" ]; then
                filename=$(basename "$img")
                # Create a readable title from filename
                title=$(echo "$filename" | sed 's/\.png$//' | sed 's/-/ /g' | sed 's/_/ /g')
                echo "### ${title}" >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
                echo "![${filename}](screenshots/${filename})" >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
                SCREENSHOT_COUNT=$((SCREENSHOT_COUNT + 1))
              fi
            done
            echo "" >> "$REPORT_FILE"
            echo "**Total screenshots captured**: ${SCREENSHOT_COUNT}" >> "$REPORT_FILE"
          else
            echo "No screenshots were captured during validation." >> "$REPORT_FILE"
          fi

          echo "Report generated: $REPORT_FILE"

      - name: Commit Results
        if: steps.detect.outputs.skip != 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git remote set-url origin "https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}"

          git add "$FOLDER/validation/" || true
          git commit -m "validation: $FEATURE_NAME exploration results" || echo "No changes to commit"
          git push || echo "Push failed"

      - name: Notify n8n
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          curl -s -X POST "https://automation-wh.bayzat.com/webhook/validation-complete" \
            -H "Content-Type: application/json" \
            -d '{
              "feature_folder": "${{ steps.detect.outputs.folder }}",
              "feature_name": "${{ steps.detect.outputs.feature_name }}",
              "status": "${{ job.status }}",
              "run_id": "${{ github.run_id }}",
              "run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }' || echo "Webhook notification failed (non-blocking)"
