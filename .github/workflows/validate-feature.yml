name: Validate Feature Guide

on:
  push:
    paths:
      - '**/validation/validation-payload.json'
  workflow_dispatch:
    inputs:
      feature_folder:
        description: 'Feature folder to validate (e.g., overtime/v1)'
        required: true
      debug_mode:
        description: 'Enable debug logging'
        required: false
        default: 'false'

env:
  PLAYWRIGHT_MCP_SERVER: "@executeautomation/playwright-mcp-server"
  NODE_VERSION: "20"

jobs:
  validate:
    runs-on: [self-hosted, validation]
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          persist-credentials: false

      - name: Detect validation payload
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.feature_folder }}" ]; then
            FOLDER="${{ github.event.inputs.feature_folder }}"
          else
            CHANGED_FILE=$(git diff --name-only HEAD~1 HEAD | grep 'validation/validation-payload.json' | head -1)
            if [ -n "$CHANGED_FILE" ]; then
              FOLDER=$(echo "$CHANGED_FILE" | sed 's|/validation/.*||')
            fi
          fi

          if [ -z "$FOLDER" ]; then
            echo "No validation request found"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          PAYLOAD_FILE="$GITHUB_WORKSPACE/$FOLDER/validation/validation-payload.json"
          if [ ! -f "$PAYLOAD_FILE" ]; then
            echo "Payload file not found: $PAYLOAD_FILE"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "folder=$FOLDER" >> $GITHUB_OUTPUT
          echo "payload_file=$PAYLOAD_FILE" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

          # Extract feature info (supports object format with .feature_info)
          FEATURE_NAME=$(jq -r '.feature_info.feature_name // .metadata.feature_name // "unknown"' "$PAYLOAD_FILE")
          FEATURE_SLUG=$(jq -r '.feature_info.feature_slug // .metadata.feature_slug // "unknown"' "$PAYLOAD_FILE")
          VERSION=$(jq -r '.feature_info.next_version // .metadata.version // "v1"' "$PAYLOAD_FILE")

          echo "feature_name=$FEATURE_NAME" >> $GITHUB_OUTPUT
          echo "feature_slug=$FEATURE_SLUG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup directories
        id: dirs
        if: steps.detect.outputs.skip != 'true'
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          BASE_DIR="$GITHUB_WORKSPACE/$FOLDER/validation"

          # Create all output directories
          mkdir -p "$BASE_DIR/screenshots"
          mkdir -p "$BASE_DIR/results"
          mkdir -p "$BASE_DIR/logs"
          mkdir -p "$BASE_DIR/artifacts"

          # Output paths for later steps
          echo "base_dir=$BASE_DIR" >> $GITHUB_OUTPUT
          echo "screenshots_dir=$BASE_DIR/screenshots" >> $GITHUB_OUTPUT
          echo "results_dir=$BASE_DIR/results" >> $GITHUB_OUTPUT
          echo "logs_dir=$BASE_DIR/logs" >> $GITHUB_OUTPUT
          echo "result_file=$BASE_DIR/result.json" >> $GITHUB_OUTPUT
          echo "report_file=$BASE_DIR/report.md" >> $GITHUB_OUTPUT
          echo "log_file=$BASE_DIR/logs/validation.log" >> $GITHUB_OUTPUT

          echo "Output directories created:"
          echo "  Screenshots: $BASE_DIR/screenshots"
          echo "  Results: $BASE_DIR/results"
          echo "  Logs: $BASE_DIR/logs"
          echo "  Artifacts: $BASE_DIR/artifacts"

      - name: Setup Node.js
        if: steps.detect.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Playwright MCP
        if: steps.detect.outputs.skip != 'true'
        run: npm install -g ${{ env.PLAYWRIGHT_MCP_SERVER }}

      - name: Run Playwright Validation
        if: steps.detect.outputs.skip != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
          APP_USERNAME: ${{ secrets.APP_USERNAME }}
          APP_PASSWORD: ${{ secrets.APP_PASSWORD }}
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          PAYLOAD_FILE="${{ steps.detect.outputs.payload_file }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"
          SCREENSHOTS_DIR="${{ steps.dirs.outputs.screenshots_dir }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"
          LOG_FILE="${{ steps.dirs.outputs.log_file }}"

          # Create the prompt file
          PROMPT_FILE=$(mktemp)
          cat > "$PROMPT_FILE" << 'PROMPT_HEADER'
          You are a QA validation agent using Playwright MCP to explore and validate a feature in the Bayzat HR application.
          Your output will be used to generate user guides, so document EVERYTHING you see and experience.

          ## YOUR MISSION
          Freely explore the feature described in the payload below. Your goal is to:
          1. Successfully log in to the application
          2. Navigate to the feature location
          3. Explore each task/workflow described
          4. Take screenshots as evidence
          5. Document EVERYTHING - what works, what made it work, what doesn't work
          6. Capture the full user journey narrative for each screen

          ## CRITICAL FIRST STEPS

          ### Step 1: Login
          1. Navigate to the base URL (login page)
          2. Take a snapshot to see the login form
          3. Fill in the email field with the username
          4. Fill in the password field with the password
          5. Click the login/submit button
          6. Wait 3 seconds for the page to load
          7. Take a screenshot to confirm login success

          ### Step 2: Dismiss any tooltips/onboarding
          After login, run this JavaScript to remove tooltips:
          ```javascript
          () => {
            const selectors = ['[class*="tour"]', '[class*="tooltip"]', '[class*="onboarding"]',
                              '[class*="shepherd"]', '[role="dialog"]', '[aria-modal="true"]'];
            selectors.forEach(sel => {
              document.querySelectorAll(sel).forEach(el => {
                if (el.textContent.includes('Step') || el.textContent.includes('Next') ||
                    el.textContent.includes('Skip')) {
                  el.remove();
                }
              });
            });
            document.querySelectorAll('[class*="backdrop"], [class*="overlay"]').forEach(el => el.remove());
            return 'Tooltips removed';
          }
          ```

          ### Step 3: Explore the Feature
          Based on the payload's "where_to_go" and "what_to_do" sections:
          1. Navigate to the feature location
          2. For each task in "what_to_do", try to follow the steps
          3. Take screenshots at key points
          4. Note any issues or blockers you encounter

          ### Step 4: DEEP UI EXPLORATION (CRITICAL)
          Thoroughly explore ALL areas of the UI related to this feature:

          1. **Navigate every tab, section, and sub-menu** related to the feature
          2. **Click on every button, link, and interactive element** to see what happens
          3. **Open all dropdowns, modals, and expandable sections**
          4. **Test form fields** - what options are available, what validations exist

          ### Step 5: SCREEN DOCUMENTATION PROTOCOL
          For EVERY screen/page you visit, document:

          **A. All Visible Elements:**
          - Page title and breadcrumbs
          - Navigation elements (tabs, sidebar items, menu items)
          - Headers and section titles
          - Buttons (with their labels and states - enabled/disabled)
          - Links and their destinations
          - Form fields (text inputs, dropdowns, checkboxes, radio buttons, date pickers)
          - Tables (column headers, row data patterns, pagination)
          - Cards and info panels
          - Status indicators and badges
          - Icons and their meanings
          - Empty states and placeholder text

          **B. Interactive Element Exploration:**
          For each button/link, document:
          - What it's labeled
          - Whether it's clickable or disabled
          - What happens when clicked (modal opens, page navigates, action executes)
          - Any confirmation dialogs that appear

          **C. Form Field Documentation:**
          For each form field:
          - Field label and placeholder text
          - Whether it's required or optional
          - Input type (text, number, date, dropdown, etc.)
          - Available options (for dropdowns/selects)
          - Validation rules (when do errors appear?)
          - Default/pre-filled values
          - Help text or tooltips

          **D. State Documentation:**
          - What changes when data exists vs. empty state
          - Loading states and spinners
          - Success/error messages
          - Permission-based visibility (what might be hidden for other roles)

          ## OUTPUT FORMAT
          At the end, create a JSON result with this structure:
          {
            "validation_status": "completed" or "partial" or "blocked",
            "login_success": true/false,
            "feature_accessible": true/false,
            "feature_info": {
              "name": "Feature Name",
              "slug": "feature-slug",
              "category": "category",
              "url": "/path/to/feature"
            },
            "exploration_journey": [
              {
                "screen_name": "Screen/Page Name",
                "url": "/path/to/screen",
                "screenshot": "screenshot-name.png",
                "what_i_went_through": "Narrative of navigation path to reach this screen",
                "what_i_came_across": "What elements and sections were present on the screen",
                "what_i_saw": {
                  "page_structure": "Description of layout and main sections",
                  "visible_elements": ["List of all visible UI elements"],
                  "data_displayed": "What data/information was shown",
                  "empty_states": "Any empty states or placeholder messages"
                },
                "actions_i_performed": [
                  {
                    "action": "What I did (clicked, typed, selected, etc.)",
                    "target": "Which element I interacted with",
                    "result": "What happened after the action",
                    "screenshot_after": "screenshot-after-action.png"
                  }
                ],
                "results_i_got": {
                  "success_outcomes": ["What worked successfully"],
                  "error_outcomes": ["Any errors or issues encountered"],
                  "unexpected_behaviors": ["Anything surprising or unexpected"]
                }
              }
            ],
            "tasks_explored": [
              {
                "task": "task name",
                "status": "completed" or "partial" or "blocked",
                "notes": "what you observed",
                "screenshots": ["screenshot1.png"]
              }
            ],
            "full_behavior_catalog": {
              "buttons": [
                {
                  "label": "Button text",
                  "location": "Where on the screen",
                  "state": "enabled/disabled",
                  "action_result": "What happens when clicked"
                }
              ],
              "dropdowns": [
                {
                  "label": "Dropdown label",
                  "options": ["List of available options"],
                  "default_value": "Pre-selected value if any"
                }
              ],
              "form_fields": [
                {
                  "label": "Field label",
                  "type": "text/number/date/dropdown/checkbox/etc",
                  "required": true/false,
                  "placeholder": "Placeholder text",
                  "validation": "Validation rule if any",
                  "error_message": "Error shown when invalid"
                }
              ],
              "tabs": [
                {
                  "label": "Tab name",
                  "content_summary": "What the tab contains",
                  "item_count": "Number of items if applicable"
                }
              ],
              "modals_dialogs": [
                {
                  "trigger": "What opens this modal",
                  "title": "Modal title",
                  "content": "What's inside the modal",
                  "actions": ["Available action buttons"]
                }
              ],
              "tables": [
                {
                  "location": "Where the table is",
                  "columns": ["Column headers"],
                  "row_actions": ["Actions available per row"],
                  "pagination": "Pagination details if any"
                }
              ],
              "filters": [
                {
                  "filter_name": "Name of filter",
                  "filter_type": "dropdown/date/text/range",
                  "options": ["Available filter options"]
                }
              ],
              "notifications_alerts": [
                {
                  "type": "success/error/warning/info",
                  "trigger": "When it appears",
                  "message": "The message content"
                }
              ]
            },
            "ui_behaviors_documented": {
              "disabled_states": [
                {"element": "element name", "condition": "when/why it's disabled"}
              ],
              "conditional_logic": [
                {"trigger": "what action", "result": "what appears/changes"}
              ],
              "progressive_disclosure": [
                {"action": "user action", "reveals": "what new content appears"}
              ],
              "required_fields": ["list of required fields"],
              "optional_fields": ["list of optional fields"],
              "default_values": [
                {"field": "field name", "default": "default value"}
              ],
              "validation_rules": [
                {"field": "field name", "rule": "validation rule", "error_message": "message shown"}
              ],
              "tooltips_help_text": [
                {"element": "element name", "text": "tooltip/help content"}
              ]
            },
            "what_works": [
              {
                "feature_aspect": "What functionality works",
                "description": "How it works",
                "user_benefit": "Why this is good for users"
              }
            ],
            "what_made_it_work": [
              {
                "success_factor": "What enabled the success",
                "prerequisites": "What needed to be in place",
                "steps_taken": ["Steps that led to success"]
              }
            ],
            "whats_not_working": [
              {
                "issue": "What doesn't work or has problems",
                "symptoms": "How the issue manifests",
                "impact": "Effect on user experience",
                "possible_cause": "Suspected reason if identifiable"
              }
            ],
            "ui_sections_explored": ["list of all sections/tabs/pages visited"],
            "issues_found": ["list of any issues"],
            "known_issues_validated": [
              {
                "issue": "Issue from payload",
                "status": "confirmed/not_validated/not_reproducible",
                "evidence": "What confirmed or disproved it"
              }
            ],
            "screenshots_taken": 0,
            "validation_timestamp": "ISO timestamp",
            "recommendations_for_user_guide": [
              "Specific recommendations for what to include in the user guide based on exploration"
            ],
            "summary": "Comprehensive summary of the entire exploration"
          }

          PROMPT_HEADER

          cat >> "$PROMPT_FILE" << EOF

          ## CREDENTIALS
          - Base URL: $APP_BASE_URL
          - Username: $APP_USERNAME
          - Password: $APP_PASSWORD

          ## SCREENSHOTS DIRECTORY
          Save all screenshots to: $SCREENSHOTS_DIR

          ## FEATURE PAYLOAD
          $(cat "$PAYLOAD_FILE")

          ## BEGIN EXPLORATION
          Start by setting up the browser, then login, then explore the feature freely.
          Take your time and document everything you find.
          EOF

          echo "Starting Playwright validation for: $FEATURE_NAME"
          echo "============================================"

          # Create MCP config file (avoid shell escaping issues)
          MCP_CONFIG_FILE=$(mktemp)
          cat > "$MCP_CONFIG_FILE" << 'MCPCONFIG'
          {
            "mcpServers": {
              "playwright": {
                "command": "npx",
                "args": ["@executeautomation/playwright-mcp-server"],
                "env": {
                  "HEADLESS": "false",
                  "BROWSER": "chromium"
                }
              }
            }
          }
          MCPCONFIG

          # Run Claude Code with Playwright MCP (pipe prompt via stdin)
          cat "$PROMPT_FILE" | npx @anthropic-ai/claude-code@latest \
            --print \
            --dangerously-skip-permissions \
            --max-turns 100 \
            --mcp-config "$MCP_CONFIG_FILE" \
            2>&1 | tee "$RESULT_FILE.raw"

          # Extract JSON result from output
          if [ -f "$RESULT_FILE.raw" ]; then
            # Look for JSON block in the output (between { and })
            python3 -c "
          import re
          import sys
          content = open('$RESULT_FILE.raw').read()
          # Find the last complete JSON object
          matches = re.findall(r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}', content, re.DOTALL)
          if matches:
              # Get the largest/last JSON-like block
              largest = max(matches, key=len)
              print(largest)
          " > "$RESULT_FILE" 2>/dev/null || cp "$RESULT_FILE.raw" "$RESULT_FILE"
          fi

          # Cleanup temp files
          rm -f "$MCP_CONFIG_FILE"

          echo "============================================"
          echo "Validation complete"

      - name: Generate Report
        if: steps.detect.outputs.skip != 'true'
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"
          REPORT_FILE="${{ steps.dirs.outputs.report_file }}"
          SCREENSHOTS_DIR="${{ steps.dirs.outputs.screenshots_dir }}"

          cat > "$REPORT_FILE" << EOF
          # Validation Report: $FEATURE_NAME

          **Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Run ID**: ${{ github.run_id }}

          ## Result
          \`\`\`json
          $(cat "$RESULT_FILE" 2>/dev/null || echo '{"error": "No result file generated"}')
          \`\`\`

          ## Screenshots
          $(ls -la "$SCREENSHOTS_DIR/" 2>/dev/null || echo "No screenshots found")
          EOF

          echo "Report generated: $REPORT_FILE"

      - name: Commit Results
        if: steps.detect.outputs.skip != 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git remote set-url origin "https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}"

          git add "$FOLDER/validation/" || true
          git commit -m "validation: $FEATURE_NAME exploration results" || echo "No changes to commit"
          git push || echo "Push failed"

      - name: Notify n8n
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          curl -s -X POST "https://automation-wh.bayzat.com/webhook/validation-complete" \
            -H "Content-Type: application/json" \
            -d '{
              "feature_folder": "${{ steps.detect.outputs.folder }}",
              "feature_name": "${{ steps.detect.outputs.feature_name }}",
              "status": "${{ job.status }}",
              "run_id": "${{ github.run_id }}",
              "run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }' || echo "Webhook notification failed (non-blocking)"
