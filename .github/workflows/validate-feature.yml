name: Validate Feature Guide

on:
  push:
    paths:
      - '**/validation/request.json'
  workflow_dispatch:
    inputs:
      feature_folder:
        description: 'Feature folder to validate (e.g., daily-wage-calculator/v5)'
        required: true

env:
  # Pin versions for stability
  PLAYWRIGHT_MCP_VERSION: "0.0.42"  # Avoid v0.0.47 screenshot corruption bug
  NODE_VERSION: "20"

jobs:
  validate:
    runs-on: [self-hosted, validation]
    timeout-minutes: 30

    outputs:
      validation_status: ${{ steps.validate_outputs.outputs.status }}
      screenshot_count: ${{ steps.validate_outputs.outputs.screenshot_count }}
      error_message: ${{ steps.validate_outputs.outputs.error_message }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect validation request
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.feature_folder }}" ]; then
            FOLDER="${{ github.event.inputs.feature_folder }}"
          else
            FOLDER=$(git diff --name-only HEAD~1 HEAD | grep 'validation/request.json' | head -1 | sed 's|/validation/request.json||')
          fi

          if [ -z "$FOLDER" ]; then
            echo "No validation request found"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "folder=$FOLDER" >> $GITHUB_OUTPUT
          echo "request_file=$FOLDER/validation/request.json" >> $GITHUB_OUTPUT
          echo "result_file=$FOLDER/validation/result.json" >> $GITHUB_OUTPUT
          echo "report_file=$FOLDER/validation/report.md" >> $GITHUB_OUTPUT
          echo "screenshots_dir=$FOLDER/validation/screenshots" >> $GITHUB_OUTPUT
          echo "log_file=$FOLDER/validation/validation.log" >> $GITHUB_OUTPUT
          echo "error_file=$FOLDER/validation/error.log" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "‚úÖ Found validation request: $FOLDER"

      # ============================================================
      # PRE-FLIGHT CHECKS
      # ============================================================
      - name: Pre-flight Health Checks
        id: preflight
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "üîç Running pre-flight checks..."
          ERRORS=""

          # Check ANTHROPIC_API_KEY
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            ERRORS="${ERRORS}‚ùå ANTHROPIC_API_KEY not configured\n"
          else
            echo "‚úÖ ANTHROPIC_API_KEY configured"
          fi

          # Check APP credentials
          if [ -z "${{ secrets.APP_BASE_URL }}" ]; then
            ERRORS="${ERRORS}‚ùå APP_BASE_URL not configured\n"
          else
            echo "‚úÖ APP_BASE_URL configured"
          fi

          # Check request.json exists
          if [ ! -f "$GITHUB_WORKSPACE/${{ steps.detect.outputs.request_file }}" ]; then
            ERRORS="${ERRORS}‚ùå Request file not found: ${{ steps.detect.outputs.request_file }}\n"
          else
            echo "‚úÖ Request file exists"
            # Validate JSON syntax
            if ! jq empty "$GITHUB_WORKSPACE/${{ steps.detect.outputs.request_file }}" 2>/dev/null; then
              ERRORS="${ERRORS}‚ùå Request file is not valid JSON\n"
            else
              echo "‚úÖ Request file is valid JSON"
            fi
          fi

          # Check disk space (need at least 2GB for browsers)
          AVAILABLE_GB=$(df -g "$GITHUB_WORKSPACE" | tail -1 | awk '{print $4}')
          if [ "$AVAILABLE_GB" -lt 2 ]; then
            ERRORS="${ERRORS}‚ùå Low disk space: ${AVAILABLE_GB}GB available (need 2GB)\n"
          else
            echo "‚úÖ Disk space OK: ${AVAILABLE_GB}GB available"
          fi

          if [ -n "$ERRORS" ]; then
            echo "‚ùå Pre-flight checks failed:"
            echo -e "$ERRORS"
            echo "preflight_passed=false" >> $GITHUB_OUTPUT
            echo "preflight_errors=$ERRORS" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "preflight_passed=true" >> $GITHUB_OUTPUT
          echo "‚úÖ All pre-flight checks passed"

      - name: Prepare Output Directories
        if: steps.detect.outputs.skip != 'true'
        run: |
          mkdir -p "$GITHUB_WORKSPACE/${{ steps.detect.outputs.screenshots_dir }}"
          echo "‚úÖ Screenshots directory ready"

      # ============================================================
      # INSTALLATION (with caching hints)
      # ============================================================
      - name: Install Claude CLI
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "Installing Claude CLI..."
          npm install -g @anthropic-ai/claude-code
          export PATH="$(npm prefix -g)/bin:$PATH"

          # Verify installation
          if ! command -v claude &> /dev/null; then
            echo "‚ùå Claude CLI installation failed"
            exit 1
          fi

          claude --version
          echo "‚úÖ Claude CLI installed"

      - name: Install Playwright MCP and Browsers
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "Installing Playwright MCP v${PLAYWRIGHT_MCP_VERSION}..."

          # Install specific version for stability
          npm install -g @playwright/mcp@${PLAYWRIGHT_MCP_VERSION}

          echo "Installing Playwright browsers..."
          npx -y playwright install chromium

          # Verify browser installation
          if [ ! -d ~/.cache/ms-playwright ]; then
            echo "‚ö†Ô∏è Browser cache directory not found, attempting reinstall..."
            npx -y playwright install chromium --force
          fi

          echo "‚úÖ Playwright MCP v${PLAYWRIGHT_MCP_VERSION} and browsers ready"

      - name: Setup MCP Configuration
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "Setting up MCP configuration..."
          rm -f "$GITHUB_WORKSPACE/.mcp.json"

          SCREENSHOT_PATH="$GITHUB_WORKSPACE/${{ steps.detect.outputs.screenshots_dir }}"

          # Use pinned version with output directory and trace for debugging
          cat > "$GITHUB_WORKSPACE/.mcp.json" << EOF
          {
            "mcpServers": {
              "playwright": {
                "command": "npx",
                "args": [
                  "-y",
                  "@playwright/mcp@${PLAYWRIGHT_MCP_VERSION}",
                  "--output-dir", "${SCREENSHOT_PATH}",
                  "--headless",
                  "--save-trace"
                ]
              }
            }
          }
          EOF

          echo "MCP config:"
          cat "$GITHUB_WORKSPACE/.mcp.json"
          echo "‚úÖ MCP configuration ready"

      # ============================================================
      # VALIDATION EXECUTION
      # ============================================================
      - name: Run Playwright MCP Validation
        id: validation
        if: steps.detect.outputs.skip != 'true'
        env:
          VALIDATION_REQUEST: ${{ steps.detect.outputs.request_file }}
          VALIDATION_RESULT: ${{ steps.detect.outputs.result_file }}
          FEATURE_FOLDER: ${{ steps.detect.outputs.folder }}
          SCREENSHOTS_DIR: ${{ steps.detect.outputs.screenshots_dir }}
          APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
          APP_USERNAME: ${{ secrets.APP_USERNAME }}
          APP_PASSWORD: ${{ secrets.APP_PASSWORD }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "============================================================"
          echo "üöÄ Starting validation for: $FEATURE_FOLDER"
          echo "============================================================"
          echo "Request file: $VALIDATION_REQUEST"
          echo "Screenshots directory: $SCREENSHOTS_DIR"
          echo "Target URL: $APP_BASE_URL"
          echo "Playwright MCP version: ${PLAYWRIGHT_MCP_VERSION}"
          echo "Start time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "============================================================"

          cd "$GITHUB_WORKSPACE"
          export PATH="$(npm prefix -g)/bin:$PATH"

          # Create marker file to track execution
          echo "started" > "$GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/.execution_status"

          # Run Claude CLI and capture exit code
          set +e  # Don't exit on error

          claude --allowedTools "mcp__playwright__*,Read,Write,Glob,Grep" \
                 --mcp-config ".mcp.json" \
                 --print "
          You are a comprehensive UI validation agent. Read the validation request JSON at $GITHUB_WORKSPACE/$VALIDATION_REQUEST.

          CRITICAL: You MUST complete all tasks and write all output files before finishing.

          ============================================================
          SECTION 1: AUTHENTICATION
          ============================================================
          - Navigate to: $APP_BASE_URL
          - Username: $APP_USERNAME
          - Password: $APP_PASSWORD
          - Complete login before proceeding with validation

          POST-LOGIN ONBOARDING DISMISSAL (CRITICAL):
          - After successful login, an onboarding overlay may appear showing 'Step 1 of 4' or similar
          - This modal blocks the main UI and MUST be dismissed before any navigation
          - Look for an X button (close icon) in the top-right corner of the onboarding popup
          - Click the X to dismiss the onboarding modal completely
          - Wait for the overlay to close and the main dashboard to be fully visible
          - Only proceed with feature navigation once the dashboard is clear of overlays

          ============================================================
          SECTION 2: SCREENSHOT RULES
          ============================================================
          SKIP DASHBOARD/HOME PAGE SCREENSHOTS:
          - Do NOT screenshot the dashboard/home page unless the feature being validated IS the dashboard
          - The first meaningful screenshot should be the navigation TO the feature (with side menu open)
          - Exception: If validating dashboard widgets or landing page features, then screenshot dashboard

          NAVIGATION WITH SIDE MENU:
          - When documenting how to reach a feature, capture the side menu in EXPANDED state
          - Show the menu hierarchy that leads to the feature
          - This helps users understand the navigation path
          - Screenshot naming: 01-navigation-menu-expanded.png or similar

          SCREENSHOT SPECIFICATIONS:
          - All screenshots saved to: $GITHUB_WORKSPACE/$SCREENSHOTS_DIR/
          - Use descriptive kebab-case names (max 50 characters)
          - Format: .png ONLY
          - Examples: settings-payroll-config.png, leave-policy-modal.png

          ============================================================
          SECTION 3: EXHAUSTIVE UI EXPLORATION PATTERNS
          ============================================================

          PATTERN 1 - SCROLL AND VIEWPORT EXPLORATION:
          Pages often have content BELOW the visible viewport. You MUST scroll to find it.
          - After loading any page, scroll down to check for content below the fold
          - Look for: additional form fields, tables, configuration sections, buttons
          - Take screenshots of BOTH the top and scrolled views if content exists below
          - Use browser_snapshot to detect scrollable areas
          - Critical: Some settings pages have 3-4 sections that require scrolling

          PATTERN 2 - CONDITIONAL UI / BUTTON GROUP EXPLORATION:
          Some UI elements only appear AFTER selecting specific options.
          - Identify ALL button groups, radio buttons, tabs, and toggle switches
          - Click EACH option systematically, not just the currently selected one
          - After each click, check if NEW UI elements appear
          - Screenshot the UI state for EACH option
          - Document what appears/disappears based on selection
          - Example: A 'Custom days' radio might reveal a number input field

          PATTERN 3 - DISABLED/GREYED OUT FIELD DOCUMENTATION:
          Disabled fields are CRITICAL evidence of configuration hierarchy.
          - When you find greyed-out or disabled fields, DO NOT skip them
          - Document WHY they are disabled (look for info text, tooltips, or banners)
          - Look for phrases like 'Configured in [X] setting' or 'Controlled by [Y]'
          - These indicate linked configurations that users need to understand
          - Screenshot disabled fields with their explanatory messages visible

          PATTERN 4 - INFO BANNER AND CONTEXTUAL MESSAGE CAPTURE:
          Info banners and contextual messages explain business logic.
          - Look for blue/yellow/grey information boxes at top of sections
          - Capture warning messages about impacts of changes
          - Document helper text that appears below form fields
          - These messages are essential for user guide accuracy
          - Screenshot the full context including the banner AND related fields

          PATTERN 5 - LINK RELATIONSHIP DOCUMENTATION:
          When UI shows 'Configured in X setting' with a clickable link:
          - This is CRITICAL configuration hierarchy evidence
          - Click the link to verify where it leads
          - Document the relationship between settings
          - Take screenshots showing: the link text, where it navigates to
          - This helps users understand cross-setting dependencies

          PATTERN 6 - TABLE ROW EXPLORATION:
          When a table has multiple rows with Edit/Configure buttons:
          - Click the Edit/Configure button for EACH row, not just the first
          - Each row may have different configuration options
          - Document variations between row configurations
          - Take screenshots of each unique configuration modal
          - Example: A table with 3 service types needs 3 modal screenshots

          PATTERN 7 - COMPLETE MODAL EXPLORATION:
          When opening any modal/dialog:
          - Identify ALL interactive elements within the modal
          - Open EVERY dropdown within the modal to see available options
          - Screenshot dropdown options in their expanded state
          - Look for tabs or sections within the modal
          - Scroll within the modal if it has scrollable content
          - Document any disabled fields and their explanations

          PATTERN 8 - DROPDOWN DOCUMENTATION:
          For every dropdown/select element:
          - Click to expand and see ALL available options
          - Take screenshot with dropdown OPEN showing all options
          - Note the currently selected value
          - Document what each option means if help text exists

          ============================================================
          SECTION 4: VALIDATION EXECUTION
          ============================================================

          IMPORTANT CONTEXT:
          - The nav.breadcrumb_array paths are HINTS only - they set context but may not be exact paths
          - Focus on the 'description', 'selector_hint', and 'assertion' fields to understand what to validate
          - Use your judgment to find the correct UI location if the suggested path doesn't match exactly

          FOR EACH VALIDATION PLAN:
          1. Navigate using breadcrumb_array as a guide
          2. Apply ALL exploration patterns above to the feature area
          3. Read each check's description and assertion carefully
          4. Capture comprehensive screenshot evidence
          5. Document any UI elements that don't match expected behavior

          COMPLETION CHECKLIST FOR EACH FEATURE AREA:
          - Scrolled to bottom of page to find hidden content
          - Clicked all button group options to discover conditional UI
          - Opened all edit/configure buttons in tables
          - Expanded all dropdowns within modals
          - Documented all disabled fields with their explanations
          - Captured all info banners and contextual messages
          - Followed 'Configured in X' links to document relationships

          ============================================================
          SECTION 5: MANDATORY OUTPUT FILES
          ============================================================
          YOU MUST CREATE ALL OF THESE FILES:

          1. Screenshot manifest: $GITHUB_WORKSPACE/$SCREENSHOTS_DIR/manifest.json
             - List all screenshots with descriptions
             - Map screenshots to validation checks

          2. Validation report: $GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/report.md
             - Executive summary with pass/fail counts
             - Detailed findings for each validation plan
             - Evidence references (screenshot filenames)
             - Key findings and recommendations

          3. Structured results: $GITHUB_WORKSPACE/$VALIDATION_RESULT
             - JSON format with plan statuses and check results
             - Include evidence references and notes for each check

          After completing ALL validation, write 'completed' to: $GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/.execution_status
          " 2>&1 | tee "$GITHUB_WORKSPACE/${{ steps.detect.outputs.log_file }}"

          CLAUDE_EXIT_CODE=$?
          set -e

          echo "claude_exit_code=$CLAUDE_EXIT_CODE" >> $GITHUB_OUTPUT
          echo "============================================================"
          echo "Claude CLI exit code: $CLAUDE_EXIT_CODE"
          echo "End time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "============================================================"

      # ============================================================
      # OUTPUT VALIDATION
      # ============================================================
      - name: Validate Outputs
        id: validate_outputs
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          echo "üîç Validating output files..."

          FOLDER="${{ steps.detect.outputs.folder }}"
          SCREENSHOTS_DIR="${{ steps.detect.outputs.screenshots_dir }}"
          RESULT_FILE="${{ steps.detect.outputs.result_file }}"
          REPORT_FILE="${{ steps.detect.outputs.report_file }}"
          LOG_FILE="${{ steps.detect.outputs.log_file }}"

          STATUS="success"
          ERROR_MESSAGE=""
          SCREENSHOT_COUNT=0

          # Check execution status
          EXEC_STATUS=$(cat "$GITHUB_WORKSPACE/$FOLDER/validation/.execution_status" 2>/dev/null || echo "unknown")
          echo "Execution status: $EXEC_STATUS"

          # Check validation log
          LOG_SIZE=$(wc -c < "$GITHUB_WORKSPACE/$LOG_FILE" 2>/dev/null || echo "0")
          echo "Validation log size: $LOG_SIZE bytes"
          if [ "$LOG_SIZE" -lt 100 ]; then
            STATUS="failed"
            ERROR_MESSAGE="Validation log is empty or too small (${LOG_SIZE} bytes)"
            echo "‚ùå $ERROR_MESSAGE"
          else
            echo "‚úÖ Validation log has content"
          fi

          # Check screenshots
          if [ -d "$GITHUB_WORKSPACE/$SCREENSHOTS_DIR" ]; then
            SCREENSHOT_COUNT=$(find "$GITHUB_WORKSPACE/$SCREENSHOTS_DIR" -name "*.png" | wc -l | tr -d ' ')
            echo "Screenshots found: $SCREENSHOT_COUNT"
            if [ "$SCREENSHOT_COUNT" -eq 0 ]; then
              STATUS="failed"
              ERROR_MESSAGE="${ERROR_MESSAGE}; No screenshots captured"
              echo "‚ùå No screenshots found"
            else
              echo "‚úÖ $SCREENSHOT_COUNT screenshots captured"
            fi
          else
            STATUS="failed"
            ERROR_MESSAGE="${ERROR_MESSAGE}; Screenshots directory missing"
            echo "‚ùå Screenshots directory not found"
          fi

          # Check manifest
          MANIFEST="$GITHUB_WORKSPACE/$SCREENSHOTS_DIR/manifest.json"
          if [ -f "$MANIFEST" ]; then
            if jq empty "$MANIFEST" 2>/dev/null; then
              echo "‚úÖ Screenshot manifest is valid JSON"
            else
              echo "‚ö†Ô∏è Screenshot manifest is not valid JSON"
            fi
          else
            echo "‚ö†Ô∏è Screenshot manifest not found (will be created)"
          fi

          # Check result.json
          if [ -f "$GITHUB_WORKSPACE/$RESULT_FILE" ]; then
            if jq empty "$GITHUB_WORKSPACE/$RESULT_FILE" 2>/dev/null; then
              echo "‚úÖ result.json exists and is valid"
            else
              STATUS="failed"
              ERROR_MESSAGE="${ERROR_MESSAGE}; result.json is not valid JSON"
              echo "‚ùå result.json is not valid JSON"
            fi
          else
            STATUS="failed"
            ERROR_MESSAGE="${ERROR_MESSAGE}; result.json not generated"
            echo "‚ùå result.json not found"
          fi

          # Check report.md
          if [ -f "$GITHUB_WORKSPACE/$REPORT_FILE" ]; then
            REPORT_SIZE=$(wc -c < "$GITHUB_WORKSPACE/$REPORT_FILE")
            if [ "$REPORT_SIZE" -gt 500 ]; then
              echo "‚úÖ report.md exists ($REPORT_SIZE bytes)"
            else
              echo "‚ö†Ô∏è report.md is suspiciously small ($REPORT_SIZE bytes)"
            fi
          else
            STATUS="failed"
            ERROR_MESSAGE="${ERROR_MESSAGE}; report.md not generated"
            echo "‚ùå report.md not found"
          fi

          # Generate manifest if missing but screenshots exist
          if [ ! -f "$MANIFEST" ] && [ "$SCREENSHOT_COUNT" -gt 0 ]; then
            echo "üìù Generating screenshot manifest..."
            echo "{" > "$MANIFEST"
            echo "  \"generated_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> "$MANIFEST"
            echo "  \"total_screenshots\": $SCREENSHOT_COUNT," >> "$MANIFEST"
            echo "  \"screenshots\": [" >> "$MANIFEST"
            FIRST=true
            for f in "$GITHUB_WORKSPACE/$SCREENSHOTS_DIR"/*.png; do
              if [ -f "$f" ]; then
                FILENAME=$(basename "$f")
                if [ "$FIRST" = true ]; then
                  FIRST=false
                else
                  echo "," >> "$MANIFEST"
                fi
                echo -n "    {\"filename\": \"$FILENAME\", \"category\": \"auto-detected\"}" >> "$MANIFEST"
              fi
            done
            echo "" >> "$MANIFEST"
            echo "  ]" >> "$MANIFEST"
            echo "}" >> "$MANIFEST"
            echo "‚úÖ Generated manifest with $SCREENSHOT_COUNT screenshots"
          fi

          # Output results
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "screenshot_count=$SCREENSHOT_COUNT" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MESSAGE" >> $GITHUB_OUTPUT

          echo "============================================================"
          echo "üìä Validation Summary"
          echo "============================================================"
          echo "Status: $STATUS"
          echo "Screenshots: $SCREENSHOT_COUNT"
          echo "Errors: ${ERROR_MESSAGE:-none}"
          echo "============================================================"

      # ============================================================
      # CLEANUP & COMMIT
      # ============================================================
      - name: Cleanup Browser Processes
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          pkill -f "mcp-server-playwright" 2>/dev/null || true
          pkill -f "chrome.*playwright" 2>/dev/null || true
          pkill -f "Google Chrome.*--remote-debugging" 2>/dev/null || true
          pkill -f "Chromium" 2>/dev/null || true
          echo "‚úÖ Browser cleanup complete"

      - name: Commit Results
        if: steps.detect.outputs.skip != 'true'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # Remove execution status file (internal use only)
          rm -f "$GITHUB_WORKSPACE/${{ steps.detect.outputs.folder }}/validation/.execution_status"

          git add "${{ steps.detect.outputs.folder }}/validation/" || true

          COMMIT_MSG="validation: ${{ steps.validate_outputs.outputs.status }} for ${{ steps.detect.outputs.folder }}"
          if [ "${{ steps.validate_outputs.outputs.status }}" = "failed" ]; then
            COMMIT_MSG="validation: ‚ùå FAILED for ${{ steps.detect.outputs.folder }}"
          fi

          git commit -m "$COMMIT_MSG" || echo "No changes to commit"
          git push || echo "Push failed"

      # ============================================================
      # NOTIFICATIONS
      # ============================================================
      - name: Notify n8n Complete
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          STATUS="${{ steps.validate_outputs.outputs.status }}"
          SCREENSHOT_COUNT="${{ steps.validate_outputs.outputs.screenshot_count }}"
          ERROR_MESSAGE="${{ steps.validate_outputs.outputs.error_message }}"
          CLAUDE_EXIT="${{ steps.validation.outputs.claude_exit_code }}"

          # Build comprehensive payload
          curl -s -X POST "https://automation-wh.bayzat.com/webhook/validation-complete" \
            -H "Content-Type: application/json" \
            -d "{
              \"feature_folder\": \"${{ steps.detect.outputs.folder }}\",
              \"status\": \"$STATUS\",
              \"screenshot_count\": ${SCREENSHOT_COUNT:-0},
              \"claude_exit_code\": ${CLAUDE_EXIT:-1},
              \"error_message\": \"$ERROR_MESSAGE\",
              \"run_id\": \"${{ github.run_id }}\",
              \"run_url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
              \"playwright_mcp_version\": \"${PLAYWRIGHT_MCP_VERSION}\"
            }" || echo "Webhook failed (non-blocking)"

      - name: Notify Slack
        if: always() && steps.detect.outputs.skip != 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not configured, skipping"
            exit 0
          fi

          STATUS="${{ steps.validate_outputs.outputs.status }}"
          FOLDER="${{ steps.detect.outputs.folder }}"
          SCREENSHOT_COUNT="${{ steps.validate_outputs.outputs.screenshot_count }}"
          ERROR_MESSAGE="${{ steps.validate_outputs.outputs.error_message }}"

          FEATURE_NAME=$(echo "$FOLDER" | cut -d'/' -f1)
          VERSION=$(echo "$FOLDER" | cut -d'/' -f2)

          if [ "$STATUS" = "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
          else
            EMOJI=":x:"
            COLOR="danger"
          fi

          REPO_URL="https://github.com/${{ github.repository }}"
          VALIDATION_URL="$REPO_URL/tree/main/$FOLDER/validation"
          RUN_URL="$REPO_URL/actions/runs/${{ github.run_id }}"

          # Build error block if needed
          ERROR_BLOCK=""
          if [ -n "$ERROR_MESSAGE" ] && [ "$ERROR_MESSAGE" != "null" ]; then
            ERROR_BLOCK=",{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"*Error:* $ERROR_MESSAGE\"}}"
          fi

          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"blocks\": [
                  {
                    \"type\": \"header\",
                    \"text\": {
                      \"type\": \"plain_text\",
                      \"text\": \"$EMOJI Feature Validation: $STATUS\",
                      \"emoji\": true
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"fields\": [
                      {\"type\": \"mrkdwn\", \"text\": \"*Feature:*\n$FEATURE_NAME\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Version:*\n$VERSION\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Status:*\n$STATUS\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Screenshots:*\n${SCREENSHOT_COUNT:-0}\"}
                    ]
                  }
                  $ERROR_BLOCK,
                  {
                    \"type\": \"actions\",
                    \"elements\": [
                      {
                        \"type\": \"button\",
                        \"text\": {\"type\": \"plain_text\", \"text\": \"View Results\"},
                        \"url\": \"$VALIDATION_URL\"
                      },
                      {
                        \"type\": \"button\",
                        \"text\": {\"type\": \"plain_text\", \"text\": \"View Run\"},
                        \"url\": \"$RUN_URL\"
                      }
                    ]
                  }
                ]
              }]
            }" || echo "Slack notification failed (non-blocking)"
