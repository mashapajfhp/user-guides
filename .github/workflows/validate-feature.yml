name: Validate Feature Guide

on:
  push:
    paths:
      - '**/validation/validation-payload.json'
  workflow_dispatch:
    inputs:
      feature_folder:
        description: 'Feature folder to validate (e.g., overtime/v1)'
        required: true
      debug_mode:
        description: 'Enable debug logging'
        required: false
        default: 'false'

env:
  PLAYWRIGHT_MCP_SERVER: "@executeautomation/playwright-mcp-server"
  NODE_VERSION: "20"

jobs:
  validate:
    runs-on: [self-hosted, validation]
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          persist-credentials: false

      - name: Detect validation payload
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.feature_folder }}" ]; then
            FOLDER="${{ github.event.inputs.feature_folder }}"
          else
            CHANGED_FILE=$(git diff --name-only HEAD~1 HEAD | grep 'validation/validation-payload.json' | head -1)
            if [ -n "$CHANGED_FILE" ]; then
              FOLDER=$(echo "$CHANGED_FILE" | sed 's|/validation/.*||')
            fi
          fi

          if [ -z "$FOLDER" ]; then
            echo "No validation request found"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          PAYLOAD_FILE="$GITHUB_WORKSPACE/$FOLDER/validation/validation-payload.json"
          if [ ! -f "$PAYLOAD_FILE" ]; then
            echo "Payload file not found: $PAYLOAD_FILE"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "folder=$FOLDER" >> $GITHUB_OUTPUT
          echo "payload_file=$PAYLOAD_FILE" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT

          # Extract feature info (supports object format with .feature_info)
          FEATURE_NAME=$(jq -r '.feature_info.feature_name // .metadata.feature_name // "unknown"' "$PAYLOAD_FILE")
          FEATURE_SLUG=$(jq -r '.feature_info.feature_slug // .metadata.feature_slug // "unknown"' "$PAYLOAD_FILE")
          VERSION=$(jq -r '.feature_info.next_version // .metadata.version // "v1"' "$PAYLOAD_FILE")

          echo "feature_name=$FEATURE_NAME" >> $GITHUB_OUTPUT
          echo "feature_slug=$FEATURE_SLUG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup directories
        id: dirs
        if: steps.detect.outputs.skip != 'true'
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          BASE_DIR="$GITHUB_WORKSPACE/$FOLDER/validation"

          # Create all output directories
          mkdir -p "$BASE_DIR/screenshots"
          mkdir -p "$BASE_DIR/results"
          mkdir -p "$BASE_DIR/logs"
          mkdir -p "$BASE_DIR/artifacts"

          # Output paths for later steps
          echo "base_dir=$BASE_DIR" >> $GITHUB_OUTPUT
          echo "screenshots_dir=$BASE_DIR/screenshots" >> $GITHUB_OUTPUT
          echo "results_dir=$BASE_DIR/results" >> $GITHUB_OUTPUT
          echo "logs_dir=$BASE_DIR/logs" >> $GITHUB_OUTPUT
          echo "result_file=$BASE_DIR/result.json" >> $GITHUB_OUTPUT
          echo "report_file=$BASE_DIR/report.md" >> $GITHUB_OUTPUT
          echo "log_file=$BASE_DIR/logs/validation.log" >> $GITHUB_OUTPUT

          echo "Output directories created:"
          echo "  Screenshots: $BASE_DIR/screenshots"
          echo "  Results: $BASE_DIR/results"
          echo "  Logs: $BASE_DIR/logs"
          echo "  Artifacts: $BASE_DIR/artifacts"

      - name: Setup Node.js
        if: steps.detect.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Playwright MCP
        if: steps.detect.outputs.skip != 'true'
        run: npm install -g ${{ env.PLAYWRIGHT_MCP_SERVER }}

      - name: Run Playwright Validation
        if: steps.detect.outputs.skip != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
          APP_USERNAME: ${{ secrets.APP_USERNAME }}
          APP_PASSWORD: ${{ secrets.APP_PASSWORD }}
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          PAYLOAD_FILE="${{ steps.detect.outputs.payload_file }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"
          SCREENSHOTS_DIR="${{ steps.dirs.outputs.screenshots_dir }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"
          LOG_FILE="${{ steps.dirs.outputs.log_file }}"

          # Create the prompt file from external template
          PROMPT_FILE=$(mktemp)
          PROMPT_TEMPLATE="$GITHUB_WORKSPACE/.github/prompts/validation-prompt.txt"

          # Copy the base prompt template
          cat "$PROMPT_TEMPLATE" > "$PROMPT_FILE"

          # Append runtime context
          cat >> "$PROMPT_FILE" << EOF

          ## CREDENTIALS
          - Base URL: $APP_BASE_URL
          - Username: $APP_USERNAME
          - Password: $APP_PASSWORD

          ## SCREENSHOTS DIRECTORY
          Save all screenshots to: $SCREENSHOTS_DIR

          ## FEATURE PAYLOAD
          $(cat "$PAYLOAD_FILE")

          ## BEGIN EXPLORATION
          Start with PHASE 0 (browser setup and login), then follow the execution_order from the payload.

          **EFFICIENCY REMINDERS:**
          - Use browser_fill_form for login (fills email AND password in ONE call)
          - Use CLICK-BASED tour dismissal (browser_evaluate is unreliable)
          - Wait sufficiently after page loads (6-8 seconds for React apps)
          - If something fails, wait and retry once before moving on
          - Check session health periodically (are you still logged in?)
          - Focus on the main feature workflows
          - ALWAYS end with the complete JSON result

          ## FINAL OUTPUT REMINDER - DO NOT SKIP

          When you finish exploring, you MUST output a JSON block. This is MANDATORY.

          \`\`\`json
          {
            "validation_status": "completed",
            "login_success": true,
            "login_method": "browser_fill_form",
            "tour_dismissal": { "method": "click_based", "tours_dismissed": 2 },
            "feature_accessible": true,
            "feature_info": { ... },
            "execution_order_followed": [ ... ],
            "primary_entity_identified": { ... },
            "exploration_journey": [ ... ],
            "session_health": { "login_attempts": 1, "session_losses": 0 },
            "screenshots_taken": 16,
            "summary": "Your comprehensive summary here"
          }
          \`\`\`

          **The JSON block is MANDATORY. Without it, the workflow fails and your work is lost.**
          EOF

          echo "Starting Playwright validation for: $FEATURE_NAME"
          echo "============================================"

          # Create MCP config file (avoid shell escaping issues)
          MCP_CONFIG_FILE=$(mktemp)
          cat > "$MCP_CONFIG_FILE" << 'MCPCONFIG'
          {
            "mcpServers": {
              "playwright": {
                "command": "npx",
                "args": ["@executeautomation/playwright-mcp-server"],
                "env": {
                  "HEADLESS": "false",
                  "BROWSER": "chrome",
                  "VIEWPORT_WIDTH": "1280",
                  "VIEWPORT_HEIGHT": "900"
                }
              }
            }
          }
          MCPCONFIG

          # Run Claude Code with Playwright MCP (pipe prompt via stdin)
          cat "$PROMPT_FILE" | npx @anthropic-ai/claude-code@latest \
            --print \
            --dangerously-skip-permissions \
            --max-turns 300 \
            --mcp-config "$MCP_CONFIG_FILE" \
            2>&1 | tee "$RESULT_FILE.raw"

          # Extract JSON result from output using proper balanced brace parsing
          if [ -f "$RESULT_FILE.raw" ]; then
            PYEXTRACT_SCRIPT=$(mktemp)
            cat > "$PYEXTRACT_SCRIPT" << 'PYEOF'
          import sys
          import re
          import json

          raw_file = sys.argv[1]
          out_file = sys.argv[2]

          with open(raw_file, 'r', errors='ignore') as f:
              content = f.read()

          def extract_json_objects(text):
              """Extract JSON objects using balanced brace matching."""
              results = []
              i = 0
              while i < len(text):
                  if text[i] == '{':
                      depth = 0
                      start = i
                      in_string = False
                      escape_next = False
                      while i < len(text):
                          char = text[i]
                          if escape_next:
                              escape_next = False
                          elif char == '\\' and in_string:
                              escape_next = True
                          elif char == '"' and not escape_next:
                              in_string = not in_string
                          elif not in_string:
                              if char == '{':
                                  depth += 1
                              elif char == '}':
                                  depth -= 1
                                  if depth == 0:
                                      candidate = text[start:i+1]
                                      try:
                                          obj = json.loads(candidate)
                                          if isinstance(obj, dict) and any(k in obj for k in ['validation_status', 'exploration_journey', 'feature_info', 'login_success']):
                                              results.append((len(candidate), obj))
                                      except json.JSONDecodeError:
                                          pass
                                      break
                          i += 1
                  i += 1
              return results

          json_blocks = re.findall(r'```json\s*([\s\S]*?)\s*```', content)
          for block in reversed(json_blocks):
              try:
                  parsed = json.loads(block)
                  if isinstance(parsed, dict) and any(k in parsed for k in ['validation_status', 'exploration_journey', 'feature_info']):
                      with open(out_file, 'w') as f:
                          json.dump(parsed, f, indent=2)
                      print(f"Extracted JSON from code block ({len(block)} chars)")
                      sys.exit(0)
              except json.JSONDecodeError:
                  continue

          json_objects = extract_json_objects(content)
          if json_objects:
              largest = max(json_objects, key=lambda x: x[0])
              with open(out_file, 'w') as f:
                  json.dump(largest[1], f, indent=2)
              print(f"Extracted JSON using brace matching ({largest[0]} chars)")
              sys.exit(0)

          all_objects = []
          i = 0
          while i < len(content):
              if content[i] == '{':
                  for j in range(len(content) - 1, i, -1):
                      if content[j] == '}':
                          try:
                              candidate = content[i:j+1]
                              obj = json.loads(candidate)
                              if isinstance(obj, dict) and len(obj) > 3:
                                  all_objects.append((len(candidate), obj))
                              break
                          except:
                              continue
              i += 1

          if all_objects:
              largest = max(all_objects, key=lambda x: x[0])
              with open(out_file, 'w') as f:
                  json.dump(largest[1], f, indent=2)
              print(f"Extracted JSON using fallback method ({largest[0]} chars)")
              sys.exit(0)

          with open(out_file, 'w') as f:
              json.dump({
                  "error": "Could not extract valid JSON from output",
                  "raw_length": len(content),
                  "json_blocks_found": len(json_blocks),
                  "hint": "The Claude output may not have included a properly formatted JSON result"
              }, f, indent=2)
          print("WARNING: Could not extract JSON, wrote error file")
          PYEOF
            python3 "$PYEXTRACT_SCRIPT" "$RESULT_FILE.raw" "$RESULT_FILE"
            rm -f "$PYEXTRACT_SCRIPT"
          fi

          # Cleanup temp files
          rm -f "$MCP_CONFIG_FILE" "$PROMPT_FILE"

          echo "============================================"
          echo "Validation complete"

      - name: Merge Payload Data into Result
        if: steps.detect.outputs.skip != 'true'
        run: |
          PAYLOAD_FILE="${{ steps.detect.outputs.payload_file }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"

          echo "Merging payload data into result.json..."

          # Merge what_to_watch_out_for, what_to_do, feature_info from payload into result
          PYMERGE_SCRIPT=$(mktemp)
          cat > "$PYMERGE_SCRIPT" << 'PYEOF'
          import sys
          import json

          payload_file = sys.argv[1]
          result_file = sys.argv[2]

          try:
              with open(payload_file, 'r') as f:
                  payload_data = json.load(f)
                  if isinstance(payload_data, list) and len(payload_data) > 0:
                      payload_data = payload_data[0]
          except Exception as e:
              print(f"Warning: Could not load payload: {e}")
              payload_data = {}

          try:
              with open(result_file, 'r') as f:
                  result_data = json.load(f)
          except Exception as e:
              print(f"Warning: Could not load result: {e}")
              result_data = {}

          playwright_context = payload_data.get('playwright_context', {})

          what_to_watch_out_for = (
              playwright_context.get('what_to_watch_out_for') or
              payload_data.get('what_to_watch_out_for') or
              []
          )

          what_to_do = (
              playwright_context.get('what_to_do') or
              payload_data.get('what_to_do') or
              []
          )

          feature_info = (
              payload_data.get('feature_info') or
              playwright_context.get('feature_metadata') or
              {}
          )

          detected_integrations = (
              payload_data.get('detected_integrations') or
              playwright_context.get('detected_integrations') or
              {}
          )

          result_data['payload_context'] = {
              'what_to_watch_out_for': what_to_watch_out_for,
              'what_to_do': what_to_do,
              'feature_info': feature_info,
              'detected_integrations': detected_integrations,
              'limitations_count': len(what_to_watch_out_for),
              'tasks_count': len(what_to_do)
          }

          if what_to_watch_out_for and 'what_to_watch_out_for' not in result_data:
              result_data['what_to_watch_out_for'] = what_to_watch_out_for

          if what_to_do and 'what_to_do' not in result_data:
              result_data['what_to_do'] = what_to_do

          with open(result_file, 'w') as f:
              json.dump(result_data, f, indent=2)

          print(f"Merged payload data into result:")
          print(f"  - what_to_watch_out_for: {len(what_to_watch_out_for)} items")
          print(f"  - what_to_do: {len(what_to_do)} tasks")
          print(f"  - feature_info: {feature_info.get('feature_name', 'unknown')}")
          PYEOF
          python3 "$PYMERGE_SCRIPT" "$PAYLOAD_FILE" "$RESULT_FILE"
          rm -f "$PYMERGE_SCRIPT"

      - name: Generate Report
        if: steps.detect.outputs.skip != 'true'
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"
          FEATURE_SLUG="${{ steps.detect.outputs.feature_slug }}"
          RESULT_FILE="${{ steps.dirs.outputs.result_file }}"
          REPORT_FILE="${{ steps.dirs.outputs.report_file }}"
          SCREENSHOTS_DIR="${{ steps.dirs.outputs.screenshots_dir }}"

          # Start report - write header
          {
            echo "# Validation Report: ${FEATURE_NAME}"
            echo ""
            echo "**Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "**Run ID**: ${{ github.run_id }}"
            echo ""
            echo "## Result"
            echo ""
            echo '```json'
            cat "$RESULT_FILE" 2>/dev/null || echo '{"error": "No result file generated"}'
            echo '```'
            echo ""
            echo "## Screenshots"
            echo ""
          } > "$REPORT_FILE"

          # Add screenshots as markdown image links
          if [ -d "$SCREENSHOTS_DIR" ] && [ "$(ls -A "$SCREENSHOTS_DIR" 2>/dev/null)" ]; then
            SCREENSHOT_COUNT=0
            for img in "$SCREENSHOTS_DIR"/*.png; do
              if [ -f "$img" ]; then
                filename=$(basename "$img")
                # Create a readable title from filename
                title=$(echo "$filename" | sed 's/\.png$//' | sed 's/-/ /g' | sed 's/_/ /g')
                echo "### ${title}" >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
                echo "![${filename}](screenshots/${filename})" >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
                SCREENSHOT_COUNT=$((SCREENSHOT_COUNT + 1))
              fi
            done
            echo "" >> "$REPORT_FILE"
            echo "**Total screenshots captured**: ${SCREENSHOT_COUNT}" >> "$REPORT_FILE"
          else
            echo "No screenshots were captured during validation." >> "$REPORT_FILE"
          fi

          echo "Report generated: $REPORT_FILE"

      - name: Commit Results
        if: steps.detect.outputs.skip != 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          FOLDER="${{ steps.detect.outputs.folder }}"
          FEATURE_NAME="${{ steps.detect.outputs.feature_name }}"

          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git remote set-url origin "https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}"

          git add "$FOLDER/validation/" || true
          git commit -m "validation: $FEATURE_NAME exploration results" || echo "No changes to commit"
          git push || echo "Push failed"

      - name: Notify n8n
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          curl -s -X POST "https://automation-wh.bayzat.com/webhook/validation-complete" \
            -H "Content-Type: application/json" \
            -d '{
              "feature_folder": "${{ steps.detect.outputs.folder }}",
              "feature_name": "${{ steps.detect.outputs.feature_name }}",
              "status": "${{ job.status }}",
              "run_id": "${{ github.run_id }}",
              "run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }' || echo "Webhook notification failed (non-blocking)"
