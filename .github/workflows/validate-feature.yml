name: Validate Feature Guide

on:
  push:
    paths:
      - '**/validation/request.json'
      - '**/validation/validation-payload.json'
  workflow_dispatch:
    inputs:
      feature_folder:
        description: 'Feature folder to validate (e.g., daily-wage-calculator/v5)'
        required: true
      payload_format:
        description: 'Payload format (auto-detect, legacy, n8n-v1)'
        required: false
        default: 'auto-detect'

env:
  # Pin versions for stability
  PLAYWRIGHT_MCP_VERSION: "0.0.42"  # Avoid v0.0.47 screenshot corruption bug
  NODE_VERSION: "20"

jobs:
  validate:
    runs-on: [self-hosted, validation]
    timeout-minutes: 45  # Increased from 30 to handle longer validations

    outputs:
      validation_status: ${{ steps.validate_outputs.outputs.status }}
      screenshot_count: ${{ steps.validate_outputs.outputs.screenshot_count }}
      error_message: ${{ steps.validate_outputs.outputs.error_message }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        timeout-minutes: 3
        with:
          fetch-depth: 2  # Need 2 commits for git diff HEAD~1
          persist-credentials: false

      - name: Detect validation request
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.feature_folder }}" ]; then
            FOLDER="${{ github.event.inputs.feature_folder }}"
          else
            # Check for both request.json (legacy) and validation-payload.json (n8n v1)
            CHANGED_FILE=$(git diff --name-only HEAD~1 HEAD | grep -E 'validation/(request\.json|validation-payload\.json)' | head -1)
            if [ -n "$CHANGED_FILE" ]; then
              # Extract folder by removing the validation/filename part
              FOLDER=$(echo "$CHANGED_FILE" | sed 's|/validation/.*||')
              echo "üîç Detected changed file: $CHANGED_FILE"
              echo "üîç Extracted folder: $FOLDER"
            fi
          fi

          if [ -z "$FOLDER" ]; then
            echo "No validation request found"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Detect payload format
          PAYLOAD_FORMAT="${{ github.event.inputs.payload_format }}"
          if [ "$PAYLOAD_FORMAT" = "auto-detect" ] || [ -z "$PAYLOAD_FORMAT" ]; then
            if [ -f "$GITHUB_WORKSPACE/$FOLDER/validation/validation-payload.json" ]; then
              PAYLOAD_FORMAT="n8n-v1"
              REQUEST_FILE="$FOLDER/validation/validation-payload.json"
              echo "üîç Detected n8n-v1 payload format (validation-payload.json)"
            elif [ -f "$GITHUB_WORKSPACE/$FOLDER/validation/request.json" ]; then
              PAYLOAD_FORMAT="legacy"
              REQUEST_FILE="$FOLDER/validation/request.json"
              echo "üîç Detected legacy payload format (request.json)"
            else
              echo "‚ùå No validation payload found in $FOLDER/validation/"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          elif [ "$PAYLOAD_FORMAT" = "n8n-v1" ]; then
            REQUEST_FILE="$FOLDER/validation/validation-payload.json"
          else
            REQUEST_FILE="$FOLDER/validation/request.json"
          fi

          echo "folder=$FOLDER" >> $GITHUB_OUTPUT
          echo "request_file=$REQUEST_FILE" >> $GITHUB_OUTPUT
          echo "payload_format=$PAYLOAD_FORMAT" >> $GITHUB_OUTPUT
          echo "result_file=$FOLDER/validation/result.json" >> $GITHUB_OUTPUT
          echo "report_file=$FOLDER/validation/report.md" >> $GITHUB_OUTPUT
          echo "screenshots_dir=$FOLDER/validation/screenshots" >> $GITHUB_OUTPUT
          echo "log_file=$FOLDER/validation/validation.log" >> $GITHUB_OUTPUT
          echo "error_file=$FOLDER/validation/error.log" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "‚úÖ Found validation request: $FOLDER (format: $PAYLOAD_FORMAT)"

      # ============================================================
      # PRE-FLIGHT CHECKS
      # ============================================================
      - name: Pre-flight Health Checks
        id: preflight
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "üîç Running pre-flight checks..."
          ERRORS=""

          # Check ANTHROPIC_API_KEY
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            ERRORS="${ERRORS}‚ùå ANTHROPIC_API_KEY not configured\n"
          else
            echo "‚úÖ ANTHROPIC_API_KEY configured"
          fi

          # Check APP credentials
          if [ -z "${{ secrets.APP_BASE_URL }}" ]; then
            ERRORS="${ERRORS}‚ùå APP_BASE_URL not configured\n"
          else
            echo "‚úÖ APP_BASE_URL configured"
          fi

          # Check request.json exists
          if [ ! -f "$GITHUB_WORKSPACE/${{ steps.detect.outputs.request_file }}" ]; then
            ERRORS="${ERRORS}‚ùå Request file not found: ${{ steps.detect.outputs.request_file }}\n"
          else
            echo "‚úÖ Request file exists"
            # Validate JSON syntax
            if ! jq empty "$GITHUB_WORKSPACE/${{ steps.detect.outputs.request_file }}" 2>/dev/null; then
              ERRORS="${ERRORS}‚ùå Request file is not valid JSON\n"
            else
              echo "‚úÖ Request file is valid JSON"
            fi
          fi

          # Check disk space (need at least 2GB for browsers)
          AVAILABLE_GB=$(df -g "$GITHUB_WORKSPACE" | tail -1 | awk '{print $4}')
          if [ "$AVAILABLE_GB" -lt 2 ]; then
            ERRORS="${ERRORS}‚ùå Low disk space: ${AVAILABLE_GB}GB available (need 2GB)\n"
          else
            echo "‚úÖ Disk space OK: ${AVAILABLE_GB}GB available"
          fi

          if [ -n "$ERRORS" ]; then
            echo "‚ùå Pre-flight checks failed:"
            echo -e "$ERRORS"
            echo "preflight_passed=false" >> $GITHUB_OUTPUT
            echo "preflight_errors=$ERRORS" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "preflight_passed=true" >> $GITHUB_OUTPUT
          echo "‚úÖ All pre-flight checks passed"

      - name: Prepare Output Directories
        if: steps.detect.outputs.skip != 'true'
        run: |
          mkdir -p "$GITHUB_WORKSPACE/${{ steps.detect.outputs.screenshots_dir }}"
          echo "‚úÖ Screenshots directory ready"

      # ============================================================
      # INSTALLATION (with caching hints)
      # ============================================================
      - name: Install Claude CLI
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "Installing Claude CLI..."
          npm install -g @anthropic-ai/claude-code
          export PATH="$(npm prefix -g)/bin:$PATH"

          # Verify installation
          if ! command -v claude &> /dev/null; then
            echo "‚ùå Claude CLI installation failed"
            exit 1
          fi

          claude --version
          echo "‚úÖ Claude CLI installed"

      - name: Install Playwright MCP and Browsers
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "Installing Playwright MCP v${PLAYWRIGHT_MCP_VERSION}..."

          # Install specific version for stability
          npm install -g @playwright/mcp@${PLAYWRIGHT_MCP_VERSION}

          echo "Installing Playwright browsers (Chrome only)..."
          npx -y playwright install chrome --force

          # Verify Chrome installation - do NOT fall back to Chromium
          if [ ! -d ~/.cache/ms-playwright ]; then
            echo "‚ùå Browser cache directory not found after installation"
            exit 1
          fi

          echo "‚úÖ Playwright MCP v${PLAYWRIGHT_MCP_VERSION} and Chrome browser ready"

      - name: Setup MCP Configuration
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "Setting up MCP configuration..."
          rm -f "$GITHUB_WORKSPACE/.mcp.json"

          SCREENSHOT_PATH="$GITHUB_WORKSPACE/${{ steps.detect.outputs.screenshots_dir }}"

          # Use pinned version with output directory, Chrome browser, and extended timeout
          # CRITICAL: 300000ms (5 minutes) timeout per action to handle slow UI operations
          cat > "$GITHUB_WORKSPACE/.mcp.json" << EOF
          {
            "mcpServers": {
              "playwright": {
                "command": "npx",
                "args": [
                  "-y",
                  "@playwright/mcp@${PLAYWRIGHT_MCP_VERSION}",
                  "--output-dir", "${SCREENSHOT_PATH}",
                  "--browser", "chrome",
                  "--timeout", "300000"
                ]
              }
            }
          }
          EOF

          echo "MCP config:"
          cat "$GITHUB_WORKSPACE/.mcp.json"
          echo "‚úÖ MCP configuration ready"

      # ============================================================
      # VALIDATION EXECUTION
      # ============================================================
      - name: Check for Recent Validation
        id: cache_check
        if: steps.detect.outputs.skip != 'true'
        run: |
          RESULT_FILE="${{ steps.detect.outputs.result_file }}"

          if [ -f "$GITHUB_WORKSPACE/$RESULT_FILE" ]; then
            # Check if result.json is valid and recent (less than 1 hour old)
            if jq empty "$GITHUB_WORKSPACE/$RESULT_FILE" 2>/dev/null; then
              # Get file age in minutes (macOS compatible)
              FILE_TIME=$(stat -f %m "$GITHUB_WORKSPACE/$RESULT_FILE" 2>/dev/null || stat -c %Y "$GITHUB_WORKSPACE/$RESULT_FILE" 2>/dev/null)
              CURRENT_TIME=$(date +%s)
              AGE_MINUTES=$(( (CURRENT_TIME - FILE_TIME) / 60 ))

              if [ "$AGE_MINUTES" -lt 60 ]; then
                echo "‚è≠Ô∏è Skipping validation - valid result.json exists (${AGE_MINUTES} minutes old)"
                echo "skip_validation=true" >> $GITHUB_OUTPUT
                echo "cache_age_minutes=$AGE_MINUTES" >> $GITHUB_OUTPUT
              else
                echo "üîÑ Result.json is ${AGE_MINUTES} minutes old - will re-validate"
                echo "skip_validation=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ö†Ô∏è Existing result.json is invalid - will re-validate"
              echo "skip_validation=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "üìù No existing result.json - will run validation"
            echo "skip_validation=false" >> $GITHUB_OUTPUT
          fi

      - name: Prepare Validation Prompt
        id: prepare_prompt
        if: steps.detect.outputs.skip != 'true' && steps.cache_check.outputs.skip_validation != 'true'
        env:
          VALIDATION_REQUEST: ${{ steps.detect.outputs.request_file }}
          VALIDATION_RESULT: ${{ steps.detect.outputs.result_file }}
          FEATURE_FOLDER: ${{ steps.detect.outputs.folder }}
          SCREENSHOTS_DIR: ${{ steps.detect.outputs.screenshots_dir }}
          PAYLOAD_FORMAT: ${{ steps.detect.outputs.payload_format }}
          APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
          APP_USERNAME: ${{ secrets.APP_USERNAME }}
          APP_PASSWORD: ${{ secrets.APP_PASSWORD }}
        run: |
          # Select instructions file based on payload format
          if [ "$PAYLOAD_FORMAT" = "n8n-v1" ]; then
            INSTRUCTIONS_FILE="$GITHUB_WORKSPACE/.github/validation-instructions-n8n-v1.md"
            echo "üìã Using n8n-v1 instructions"
          else
            INSTRUCTIONS_FILE="$GITHUB_WORKSPACE/.github/validation-instructions.md"
            echo "üìã Using legacy instructions"
          fi

          LEARNINGS_FILE="$GITHUB_WORKSPACE/LEARNINGS_AND_FEEDBACK.md"
          PROMPT_FILE="$GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/.prompt.txt"

          # Create prompt with context header
          cat > "$PROMPT_FILE" << 'PROMPT_HEADER'
          You are a comprehensive UI validation agent. Your task is to validate UI features using the provided payload.

          CRITICAL: You MUST complete all tasks and write all output files before finishing.

          PROMPT_HEADER

          # Add authentication section with actual credentials
          cat >> "$PROMPT_FILE" << EOF
          ## AUTHENTICATION CREDENTIALS
          - Navigate to: $APP_BASE_URL
          - Username: $APP_USERNAME
          - Password: $APP_PASSWORD

          ## FILE PATHS
          - Validation Payload: $GITHUB_WORKSPACE/$VALIDATION_REQUEST
          - Result JSON: $GITHUB_WORKSPACE/$VALIDATION_RESULT
          - Screenshots: $GITHUB_WORKSPACE/$SCREENSHOTS_DIR/
          - Report: $GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/report.md
          - Manifest: $GITHUB_WORKSPACE/$SCREENSHOTS_DIR/manifest.json
          - Completion marker: $GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/.execution_status

          ## PAYLOAD FORMAT: $PAYLOAD_FORMAT

          EOF

          # Append the format-specific instructions (without the header which we already added)
          tail -n +3 "$INSTRUCTIONS_FILE" >> "$PROMPT_FILE"

          # Append learnings and feedback for screenshot quality guidance
          if [ -f "$LEARNINGS_FILE" ]; then
            echo "" >> "$PROMPT_FILE"
            echo "---" >> "$PROMPT_FILE"
            echo "" >> "$PROMPT_FILE"
            echo "# SCREENSHOT QUALITY LEARNINGS (READ CAREFULLY)" >> "$PROMPT_FILE"
            echo "" >> "$PROMPT_FILE"
            echo "The following learnings are from previous validation runs. Apply these rules strictly:" >> "$PROMPT_FILE"
            echo "" >> "$PROMPT_FILE"
            cat "$LEARNINGS_FILE" >> "$PROMPT_FILE"
            echo "‚úÖ Learnings file appended to prompt"
          else
            echo "‚ö†Ô∏è Learnings file not found at $LEARNINGS_FILE"
          fi

          echo "‚úÖ Validation prompt prepared ($(wc -c < "$PROMPT_FILE") bytes, format: $PAYLOAD_FORMAT)"

      - name: Pre-Validation Browser Cleanup
        if: steps.detect.outputs.skip != 'true' && steps.cache_check.outputs.skip_validation != 'true'
        run: |
          echo "üßπ Cleaning up stale browser processes before validation..."
          # Kill any existing Playwright/Chrome processes from previous runs
          pkill -f "mcp-server-playwright" 2>/dev/null || true
          pkill -f "chrome.*playwright" 2>/dev/null || true
          pkill -f "Google Chrome.*--remote-debugging" 2>/dev/null || true
          pkill -f "Chromium" 2>/dev/null || true

          # Small delay to ensure processes are fully terminated
          sleep 2

          # Clear any stale browser user data that might cause session issues
          rm -rf /tmp/playwright-* 2>/dev/null || true

          echo "‚úÖ Pre-validation cleanup complete - fresh browser session guaranteed"

      - name: Run Playwright MCP Validation
        id: validation
        if: steps.detect.outputs.skip != 'true' && steps.cache_check.outputs.skip_validation != 'true'
        env:
          FEATURE_FOLDER: ${{ steps.detect.outputs.folder }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "============================================================"
          echo "üöÄ Starting validation for: $FEATURE_FOLDER"
          echo "============================================================"
          echo "Playwright MCP version: ${PLAYWRIGHT_MCP_VERSION}"
          echo "Start time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "============================================================"

          cd "$GITHUB_WORKSPACE"
          export PATH="$(npm prefix -g)/bin:$PATH"

          # Create marker file to track execution
          echo "started" > "$GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/.execution_status"

          # Read the prepared prompt
          PROMPT_FILE="$GITHUB_WORKSPACE/$FEATURE_FOLDER/validation/.prompt.txt"

          # Run Claude CLI and capture exit code
          set +e  # Don't exit on error

          # CRITICAL: --dangerously-skip-permissions is REQUIRED for non-interactive CI
          # Without this flag, Claude will prompt for file write approval and hang/skip
          # The v13 validation failed because it couldn't write result.json without approval
          claude --model sonnet \
                 --allowedTools "mcp__playwright__*,Read,Write,Glob,Grep" \
                 --mcp-config ".mcp.json" \
                 --dangerously-skip-permissions \
                 --print "$(cat "$PROMPT_FILE")" 2>&1 | tee "$GITHUB_WORKSPACE/${{ steps.detect.outputs.log_file }}"

          CLAUDE_EXIT_CODE=$?
          set -e

          # Cleanup prompt file
          rm -f "$PROMPT_FILE"

          echo "claude_exit_code=$CLAUDE_EXIT_CODE" >> $GITHUB_OUTPUT
          echo "============================================================"
          echo "Claude CLI exit code: $CLAUDE_EXIT_CODE"
          echo "End time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "============================================================"

      # ============================================================
      # OUTPUT VALIDATION
      # ============================================================
      - name: Validate Outputs
        id: validate_outputs
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          echo "üîç Validating output files..."

          FOLDER="${{ steps.detect.outputs.folder }}"
          SCREENSHOTS_DIR="${{ steps.detect.outputs.screenshots_dir }}"
          RESULT_FILE="${{ steps.detect.outputs.result_file }}"
          REPORT_FILE="${{ steps.detect.outputs.report_file }}"
          LOG_FILE="${{ steps.detect.outputs.log_file }}"

          STATUS="success"
          ERROR_MESSAGE=""
          SCREENSHOT_COUNT=0

          # Check execution status
          EXEC_STATUS=$(cat "$GITHUB_WORKSPACE/$FOLDER/validation/.execution_status" 2>/dev/null || echo "unknown")
          echo "Execution status: $EXEC_STATUS"

          # Check validation log
          LOG_SIZE=$(wc -c < "$GITHUB_WORKSPACE/$LOG_FILE" 2>/dev/null || echo "0")
          echo "Validation log size: $LOG_SIZE bytes"
          if [ "$LOG_SIZE" -lt 100 ]; then
            STATUS="failed"
            ERROR_MESSAGE="Validation log is empty or too small (${LOG_SIZE} bytes)"
            echo "‚ùå $ERROR_MESSAGE"
          else
            echo "‚úÖ Validation log has content"
          fi

          # Check screenshots
          if [ -d "$GITHUB_WORKSPACE/$SCREENSHOTS_DIR" ]; then
            SCREENSHOT_COUNT=$(find "$GITHUB_WORKSPACE/$SCREENSHOTS_DIR" -name "*.png" | wc -l | tr -d ' ')
            echo "Screenshots found: $SCREENSHOT_COUNT"
            if [ "$SCREENSHOT_COUNT" -eq 0 ]; then
              STATUS="failed"
              ERROR_MESSAGE="${ERROR_MESSAGE}; No screenshots captured"
              echo "‚ùå No screenshots found"
            else
              echo "‚úÖ $SCREENSHOT_COUNT screenshots captured"
            fi
          else
            STATUS="failed"
            ERROR_MESSAGE="${ERROR_MESSAGE}; Screenshots directory missing"
            echo "‚ùå Screenshots directory not found"
          fi

          # Check manifest
          MANIFEST="$GITHUB_WORKSPACE/$SCREENSHOTS_DIR/manifest.json"
          if [ -f "$MANIFEST" ]; then
            if jq empty "$MANIFEST" 2>/dev/null; then
              echo "‚úÖ Screenshot manifest is valid JSON"
            else
              echo "‚ö†Ô∏è Screenshot manifest is not valid JSON"
            fi
          else
            echo "‚ö†Ô∏è Screenshot manifest not found (will be created)"
          fi

          # Check result.json
          if [ -f "$GITHUB_WORKSPACE/$RESULT_FILE" ]; then
            if jq empty "$GITHUB_WORKSPACE/$RESULT_FILE" 2>/dev/null; then
              echo "‚úÖ result.json exists and is valid"
            else
              STATUS="failed"
              ERROR_MESSAGE="${ERROR_MESSAGE}; result.json is not valid JSON"
              echo "‚ùå result.json is not valid JSON"
            fi
          else
            STATUS="failed"
            ERROR_MESSAGE="${ERROR_MESSAGE}; result.json not generated"
            echo "‚ùå result.json not found"
          fi

          # Check report.md
          if [ -f "$GITHUB_WORKSPACE/$REPORT_FILE" ]; then
            REPORT_SIZE=$(wc -c < "$GITHUB_WORKSPACE/$REPORT_FILE")
            if [ "$REPORT_SIZE" -gt 500 ]; then
              echo "‚úÖ report.md exists ($REPORT_SIZE bytes)"
            else
              echo "‚ö†Ô∏è report.md is suspiciously small ($REPORT_SIZE bytes)"
            fi
          else
            STATUS="failed"
            ERROR_MESSAGE="${ERROR_MESSAGE}; report.md not generated"
            echo "‚ùå report.md not found"
          fi

          # Generate manifest if missing but screenshots exist
          if [ ! -f "$MANIFEST" ] && [ "$SCREENSHOT_COUNT" -gt 0 ]; then
            echo "üìù Generating screenshot manifest..."
            echo "{" > "$MANIFEST"
            echo "  \"generated_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> "$MANIFEST"
            echo "  \"total_screenshots\": $SCREENSHOT_COUNT," >> "$MANIFEST"
            echo "  \"screenshots\": [" >> "$MANIFEST"
            FIRST=true
            for f in "$GITHUB_WORKSPACE/$SCREENSHOTS_DIR"/*.png; do
              if [ -f "$f" ]; then
                FILENAME=$(basename "$f")
                if [ "$FIRST" = true ]; then
                  FIRST=false
                else
                  echo "," >> "$MANIFEST"
                fi
                echo -n "    {\"filename\": \"$FILENAME\", \"category\": \"auto-detected\"}" >> "$MANIFEST"
              fi
            done
            echo "" >> "$MANIFEST"
            echo "  ]" >> "$MANIFEST"
            echo "}" >> "$MANIFEST"
            echo "‚úÖ Generated manifest with $SCREENSHOT_COUNT screenshots"
          fi

          # Output results
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "screenshot_count=$SCREENSHOT_COUNT" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MESSAGE" >> $GITHUB_OUTPUT

          echo "============================================================"
          echo "üìä Validation Summary"
          echo "============================================================"
          echo "Status: $STATUS"
          echo "Screenshots: $SCREENSHOT_COUNT"
          echo "Errors: ${ERROR_MESSAGE:-none}"
          echo "============================================================"

      # ============================================================
      # CLEANUP & COMMIT
      # ============================================================
      - name: Cleanup Browser Processes
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          pkill -f "mcp-server-playwright" 2>/dev/null || true
          pkill -f "chrome.*playwright" 2>/dev/null || true
          pkill -f "Google Chrome.*--remote-debugging" 2>/dev/null || true
          pkill -f "Chromium" 2>/dev/null || true
          echo "‚úÖ Browser cleanup complete"

      - name: Commit Results
        if: steps.detect.outputs.skip != 'true'
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          # Configure git to use PAT_TOKEN for push (long-lived token, not ephemeral GITHUB_TOKEN)
          git remote set-url origin "https://x-access-token:${PAT_TOKEN}@github.com/${{ github.repository }}"

          # Remove execution status file (internal use only)
          rm -f "$GITHUB_WORKSPACE/${{ steps.detect.outputs.folder }}/validation/.execution_status"

          git add "${{ steps.detect.outputs.folder }}/validation/" || true

          COMMIT_MSG="validation: ${{ steps.validate_outputs.outputs.status }} for ${{ steps.detect.outputs.folder }}"
          if [ "${{ steps.validate_outputs.outputs.status }}" = "failed" ]; then
            COMMIT_MSG="validation: ‚ùå FAILED for ${{ steps.detect.outputs.folder }}"
          fi

          git commit -m "$COMMIT_MSG" || echo "No changes to commit"
          git push || echo "Push failed"

      # ============================================================
      # NOTIFICATIONS
      # ============================================================
      - name: Notify n8n Complete
        if: always() && steps.detect.outputs.skip != 'true'
        run: |
          STATUS="${{ steps.validate_outputs.outputs.status }}"
          SCREENSHOT_COUNT="${{ steps.validate_outputs.outputs.screenshot_count }}"
          ERROR_MESSAGE="${{ steps.validate_outputs.outputs.error_message }}"
          CLAUDE_EXIT="${{ steps.validation.outputs.claude_exit_code }}"
          PAYLOAD_FORMAT="${{ steps.detect.outputs.payload_format }}"

          # Build comprehensive payload
          curl -s -X POST "https://automation-wh.bayzat.com/webhook/validation-complete" \
            -H "Content-Type: application/json" \
            -d "{
              \"feature_folder\": \"${{ steps.detect.outputs.folder }}\",
              \"status\": \"$STATUS\",
              \"payload_format\": \"$PAYLOAD_FORMAT\",
              \"screenshot_count\": ${SCREENSHOT_COUNT:-0},
              \"claude_exit_code\": ${CLAUDE_EXIT:-1},
              \"error_message\": \"$ERROR_MESSAGE\",
              \"run_id\": \"${{ github.run_id }}\",
              \"run_url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
              \"playwright_mcp_version\": \"${PLAYWRIGHT_MCP_VERSION}\"
            }" || echo "Webhook failed (non-blocking)"

      - name: Notify Slack
        if: always() && steps.detect.outputs.skip != 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not configured, skipping"
            exit 0
          fi

          STATUS="${{ steps.validate_outputs.outputs.status }}"
          FOLDER="${{ steps.detect.outputs.folder }}"
          SCREENSHOT_COUNT="${{ steps.validate_outputs.outputs.screenshot_count }}"
          ERROR_MESSAGE="${{ steps.validate_outputs.outputs.error_message }}"
          PAYLOAD_FORMAT="${{ steps.detect.outputs.payload_format }}"

          FEATURE_NAME=$(echo "$FOLDER" | cut -d'/' -f1)
          VERSION=$(echo "$FOLDER" | cut -d'/' -f2)

          if [ "$STATUS" = "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
          else
            EMOJI=":x:"
            COLOR="danger"
          fi

          REPO_URL="https://github.com/${{ github.repository }}"
          VALIDATION_URL="$REPO_URL/tree/main/$FOLDER/validation"
          RUN_URL="$REPO_URL/actions/runs/${{ github.run_id }}"

          # Build error block if needed
          ERROR_BLOCK=""
          if [ -n "$ERROR_MESSAGE" ] && [ "$ERROR_MESSAGE" != "null" ]; then
            ERROR_BLOCK=",{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"*Error:* $ERROR_MESSAGE\"}}"
          fi

          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"blocks\": [
                  {
                    \"type\": \"header\",
                    \"text\": {
                      \"type\": \"plain_text\",
                      \"text\": \"$EMOJI Feature Validation: $STATUS\",
                      \"emoji\": true
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"fields\": [
                      {\"type\": \"mrkdwn\", \"text\": \"*Feature:*\n$FEATURE_NAME\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Version:*\n$VERSION\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Status:*\n$STATUS\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Screenshots:*\n${SCREENSHOT_COUNT:-0}\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Format:*\n$PAYLOAD_FORMAT\"}
                    ]
                  }
                  $ERROR_BLOCK,
                  {
                    \"type\": \"actions\",
                    \"elements\": [
                      {
                        \"type\": \"button\",
                        \"text\": {\"type\": \"plain_text\", \"text\": \"View Results\"},
                        \"url\": \"$VALIDATION_URL\"
                      },
                      {
                        \"type\": \"button\",
                        \"text\": {\"type\": \"plain_text\", \"text\": \"View Run\"},
                        \"url\": \"$RUN_URL\"
                      }
                    ]
                  }
                ]
              }]
            }" || echo "Slack notification failed (non-blocking)"
