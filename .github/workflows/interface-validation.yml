name: Interface Validation (Pure Agent, Anthropic Safe)

on:
  workflow_dispatch:
    inputs:
      feature_name:
        description: "Feature name to validate"
        required: true
        type: string
      feature_slug:
        description: "Feature slug with underscores for folder paths (e.g., daily_wage_calculator)"
        required: true
        type: string
      claims_json:
        description: "Claims to validate (JSON string)"
        required: true
        type: string
      navigation_paths_json:
        description: "Navigation paths (JSON string)"
        required: false
        type: string
      procedures_json:
        description: "Procedures from Zendesk documentation (JSON string)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  validate-interface:
    runs-on: self-hosted
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
      APP_USERNAME: ${{ secrets.APP_USERNAME }}
      APP_PASSWORD: ${{ secrets.APP_PASSWORD }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      # Avoid push/pull conflicts before we create files
      - name: Sync main (safe pull)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git config rebase.autoStash true
          git pull --rebase --autostash origin main || true

      # Calculate version number for this feature's validation run
      - name: Calculate validation version
        id: version
        run: |
          FEATURE_SLUG="${{ github.event.inputs.feature_slug }}"
          VALIDATION_DIR=".validation/output/${FEATURE_SLUG}"

          # Find existing versions
          if [ -d "$VALIDATION_DIR" ]; then
            LATEST_VERSION=$(ls -1d "$VALIDATION_DIR"/v*/ 2>/dev/null | sed 's/.*\/v\([0-9]*\)\//\1/' | sort -n | tail -1)
            if [ -z "$LATEST_VERSION" ]; then
              VERSION=1
            else
              VERSION=$((LATEST_VERSION + 1))
            fi
          else
            VERSION=1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üìä Validation version: v$VERSION for ${FEATURE_SLUG}"

      - name: Verify Anthropic key present (safe)
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            echo "‚ùå ANTHROPIC_API_KEY is EMPTY. Ensure repo secret 'ANTHROPIC_API_KEY' exists."
            exit 1
          fi
          echo "‚úÖ Key present (len=${#ANTHROPIC_API_KEY})"

      # Normalize to remove accidental \r or \n characters (common copy/paste issue)
      - name: Normalize Anthropic key (strip CR/LF)
        shell: bash
        run: |
          set -euo pipefail
          ANTHROPIC_API_KEY="$(printf '%s' "$ANTHROPIC_API_KEY" | tr -d '\r\n')"
          echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" >> "$GITHUB_ENV"
          echo "‚úÖ Normalized key length=${#ANTHROPIC_API_KEY}"

      # Your requested diagnostic block (prints only length + a few chars, not full key)
      - name: Debug API Key in GitHub Actions (diagnostic + real API call)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== API Key Diagnostics ==="
          echo "Key length: ${#ANTHROPIC_API_KEY}"
          echo "Key starts with sk-ant: $(echo "${ANTHROPIC_API_KEY}" | grep -q '^sk-ant' && echo 'YES' || echo 'NO')"
          echo "First 10 chars: ${ANTHROPIC_API_KEY:0:10}"
          echo "Last 10 chars:  ${ANTHROPIC_API_KEY: -10}"

          HTTP_CODE=$(curl -sS -o /tmp/anthropic_diag.json -w "%{http_code}" \
            https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${ANTHROPIC_API_KEY}" \
            -H "anthropic-version: 2023-06-01" \
            -d '{
              "model": "claude-3-5-haiku-20241022",
              "max_tokens": 5,
              "messages": [{"role":"user","content":"hi"}]
            }')

          echo "Anthropic HTTP status: ${HTTP_CODE}"
          cat /tmp/anthropic_diag.json || true

          if [ "${HTTP_CODE}" != "200" ]; then
            echo "‚ùå API call failed"
            exit 1
          fi
          echo "‚úÖ API call succeeded"

      - name: Verify Claude Code CLI available
        shell: bash
        run: |
          set -euo pipefail
          which claude
          claude --version | tee /tmp/claude_version.txt
          grep -q "Claude Code" /tmp/claude_version.txt || {
            echo "‚ùå Claude Code CLI required. Install on runner:"
            echo "   npm uninstall -g claude || true"
            echo "   npm install -g @anthropic-ai/claude-code"
            exit 1
          }

      - name: Ensure jq is installed
        shell: bash
        run: |
          set -euo pipefail
          if command -v jq >/dev/null 2>&1; then
            echo "‚úÖ jq is installed"
            jq --version
            exit 0
          fi

          echo "jq not found. Installing..."
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          elif command -v brew >/dev/null 2>&1; then
            brew install jq
          else
            echo "‚ùå Could not install jq automatically. Please install jq on the self-hosted runner."
            exit 1
          fi
          jq --version

      - name: Verify App login config present (safe)
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${APP_BASE_URL:-}" ]; then
            echo "‚ùå APP_BASE_URL is EMPTY. Ensure repo secret 'APP_BASE_URL' exists."
            exit 1
          fi
          if [ -z "${APP_USERNAME:-}" ]; then
            echo "‚ùå APP_USERNAME is EMPTY. Ensure repo secret 'APP_USERNAME' exists."
            exit 1
          fi
          if [ -z "${APP_PASSWORD:-}" ]; then
            echo "‚ùå APP_PASSWORD is EMPTY. Ensure repo secret 'APP_PASSWORD' exists."
            exit 1
          fi

          echo "‚úÖ APP_BASE_URL present (len=${#APP_BASE_URL})"
          echo "‚úÖ APP_USERNAME present (len=${#APP_USERNAME})"
          echo "‚úÖ APP_PASSWORD present (len=${#APP_PASSWORD})"

      - name: Write validation input JSON (safe)
        shell: bash
        env:
          CLAIMS_JSON: ${{ github.event.inputs.claims_json }}
          NAV_JSON: ${{ github.event.inputs.navigation_paths_json }}
          PROCEDURES_JSON: ${{ github.event.inputs.procedures_json }}
          FEATURE_NAME: ${{ github.event.inputs.feature_name }}
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail

          # Create versioned folder structure: .validation/output/{feature_slug}/v{version}/
          VERSIONED_DIR=".validation/output/${FEATURE_SLUG}/v${VERSION}"
          echo "üìÅ Creating versioned directory: ${VERSIONED_DIR}"
          mkdir -p "${VERSIONED_DIR}/screenshots"
          mkdir -p .validation/input

          # Use environment variables to avoid shell escaping issues
          CLAIMS_RAW="${CLAIMS_JSON}"
          NAV_RAW="${NAV_JSON}"
          PROCEDURES_RAW="${PROCEDURES_JSON}"
          [ -z "${NAV_RAW}" ] && NAV_RAW='[]'
          [ -z "${PROCEDURES_RAW}" ] && PROCEDURES_RAW='[]'

          # Validate JSON
          echo "${CLAIMS_RAW}" | jq -e . >/dev/null || { echo "‚ùå Invalid claims JSON"; exit 1; }
          echo "${NAV_RAW}" | jq -e . >/dev/null || { echo "‚ùå Invalid navigation JSON"; exit 1; }
          echo "${PROCEDURES_RAW}" | jq -e . >/dev/null || { echo "‚ùå Invalid procedures JSON"; exit 1; }

          jq -n \
            --arg feature_name "${FEATURE_NAME}" \
            --argjson claims_to_validate "${CLAIMS_RAW}" \
            --argjson navigation_paths "${NAV_RAW}" \
            --argjson procedures "${PROCEDURES_RAW}" \
            --arg app_base_url "${APP_BASE_URL}" \
            --arg app_username "${APP_USERNAME}" \
            --arg app_password "${APP_PASSWORD}" \
            '{
              feature_name: $feature_name,
              claims_to_validate: $claims_to_validate,
              navigation_paths: $navigation_paths,
              procedures: $procedures,
              app: {
                base_url: $app_base_url,
                username: $app_username,
                password: $app_password
              }
            }' > .validation/input/request.json

          echo "Wrote request.json:"
          # Do NOT print password; redact it for logs
          jq '.app.password="***REDACTED***"' .validation/input/request.json

      - name: Setup Node (for Playwright)
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright deps
        shell: bash
        run: |
          set -euo pipefail
          npm ci
          npx playwright install --with-deps

      - name: Run Playwright validation (UI execution)
        shell: bash
        env:
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          VERSIONED_DIR=".validation/output/${FEATURE_SLUG}/v${VERSION}"

          echo "üì∏ Screenshots will be saved to: ${VERSIONED_DIR}/screenshots/"
          node scripts/playwright/run-validation.mjs \
            --input .validation/input/request.json \
            --out "${VERSIONED_DIR}/pw_result.json" \
            --screenshots "${VERSIONED_DIR}/screenshots"

      - name: Clean JSON Output (Playwright) - ensure valid JSON file exists
        shell: bash
        env:
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          VERSIONED_DIR=".validation/output/${FEATURE_SLUG}/v${VERSION}"
          test -f "${VERSIONED_DIR}/pw_result.json"
          jq -e . "${VERSIONED_DIR}/pw_result.json" >/dev/null
          echo "‚úÖ pw_result.json is valid JSON in ${VERSIONED_DIR}"

      - name: Run Interface Validator Agent (PURE, STRICT JSON)
        shell: bash
        env:
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          VERSIONED_DIR=".validation/output/${FEATURE_SLUG}/v${VERSION}"
          mkdir -p "${VERSIONED_DIR}"

          INPUT_JSON="$(cat .validation/input/request.json)"

          # IMPORTANT:
          # - The heredoc BODY MUST be indented (it is) so YAML doesn't try to parse lines like "SYSTEM (NON-NEGOTIABLE)".
          # - Keep the closing marker at column 1 in bash terms; YAML will still treat it as part of the run block.
          cat > "${VERSIONED_DIR}/agent_prompt.txt" <<'__AGENT_PROMPT__'
          SYSTEM (NON-NEGOTIABLE)

          You are InterfaceValidatorAgent.
          You are NOT a general assistant.

          - Do NOT greet.
          - Do NOT ask questions.
          - Do NOT offer unrelated help.
          - Do NOT execute UI. (Logic-only validation.)
          - Output MUST be exactly one valid JSON object.
          - No markdown.
          - No backticks.
          - No prose.

          If required input is missing or invalid:
          Return:
          { "status": "error", "reason": "invalid_input" }

          TASK

          Given INPUT_JSON containing:
          - feature_name (string)
          - claims_to_validate (array)
          - navigation_paths (array)

          You MUST:
          1. Validate each claim logically (no UI execution)
          2. Produce deterministic validation results
          3. Output strictly valid JSON

          OUTPUT SCHEMA (MANDATORY)

          {
            "status": "ok",
            "feature_name": string,
            "validated_claims": array,
            "summary": string
          }
          __AGENT_PROMPT__

          # Run Claude; capture raw output (Claude sometimes wraps JSON in ```json fences)
          claude -p --output-format text \
            "$(cat "${VERSIONED_DIR}/agent_prompt.txt")

          INPUT_JSON:
          ${INPUT_JSON}
          " > "${VERSIONED_DIR}/result_raw.txt"

          echo "Saved: ${VERSIONED_DIR}/result_raw.txt"
          cat "${VERSIONED_DIR}/result_raw.txt"

      # Clean any ```json fences / extra text and write valid JSON only
      - name: Clean JSON Output (strip fences / extract object)
        shell: bash
        env:
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          VERSIONED_DIR=".validation/output/${FEATURE_SLUG}/v${VERSION}"

          python3 - "${VERSIONED_DIR}" <<'PY'
          import json, re, pathlib, sys

          versioned_dir = pathlib.Path(sys.argv[1])
          raw_path = versioned_dir / "result_raw.txt"
          out_path = versioned_dir / "result.json"

          s = raw_path.read_text(encoding="utf-8", errors="replace").strip()

          # Remove common fenced code blocks
          s = re.sub(r"^```(?:json)?\s*", "", s.strip(), flags=re.IGNORECASE)
          s = re.sub(r"\s*```$", "", s.strip())

          # Extract the first JSON object (best-effort)
          start = s.find("{")
          end = s.rfind("}")
          if start == -1 or end == -1 or end <= start:
            raise SystemExit("Could not find JSON object in output")

          candidate = s[start:end+1].strip()
          obj = json.loads(candidate)  # validate JSON
          out_path.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
          print("‚úÖ Clean JSON saved to", out_path)
          PY

          echo "Cleaned JSON:"
          cat "${VERSIONED_DIR}/result.json"

          # Validate schema quickly
          jq -e 'type=="object"' "${VERSIONED_DIR}/result.json" >/dev/null

          STATUS="$(jq -r '.status // empty' "${VERSIONED_DIR}/result.json")"

          if [ "$STATUS" = "ok" ]; then
            jq -e '.feature_name and (.validated_claims|type=="array") and .summary' "${VERSIONED_DIR}/result.json" >/dev/null
            echo "‚úÖ Output is valid JSON and matches required OK schema"
          elif [ "$STATUS" = "error" ]; then
            jq -e '.reason' "${VERSIONED_DIR}/result.json" >/dev/null
            echo "‚úÖ Output is valid JSON and matches required ERROR schema"
          else
            echo "‚ùå Output JSON missing valid status (ok|error)"
            exit 1
          fi

      - name: Upload validation output artifact
        uses: actions/upload-artifact@v4
        with:
          name: interface-validation-${{ github.event.inputs.feature_slug }}-v${{ steps.version.outputs.version }}-${{ github.run_id }}
          path: |
            .validation/output/${{ github.event.inputs.feature_slug }}/v${{ steps.version.outputs.version }}/result.json
            .validation/output/${{ github.event.inputs.feature_slug }}/v${{ steps.version.outputs.version }}/result_raw.txt
            .validation/output/${{ github.event.inputs.feature_slug }}/v${{ steps.version.outputs.version }}/pw_result.json
            .validation/output/${{ github.event.inputs.feature_slug }}/v${{ steps.version.outputs.version }}/screenshots/**
            .validation/input/request.json
          if-no-files-found: error
          retention-days: 7

      - name: Commit validation output
        shell: bash
        env:
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          git add .validation || true

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "Interface validation v${VERSION}: ${{ github.event.inputs.feature_name }} (${FEATURE_SLUG})"
          git push
          echo "‚úÖ Committed validation outputs to: .validation/output/${FEATURE_SLUG}/v${VERSION}/"
