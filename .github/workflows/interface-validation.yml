name: Interface Validation (Pure Agent, Anthropic Safe)

on:
  workflow_dispatch:
    inputs:
      feature_name:
        description: "Feature name to validate"
        required: true
        type: string
      claims_json:
        description: "Claims to validate (JSON string)"
        required: true
        type: string
      navigation_paths_json:
        description: "Navigation paths (JSON string)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  validate-interface:
    runs-on: self-hosted
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
      APP_USERNAME: ${{ secrets.APP_USERNAME }}
      APP_PASSWORD: ${{ secrets.APP_PASSWORD }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      # Avoid push/pull conflicts before we create files
      - name: Sync main (safe pull)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git config rebase.autoStash true
          git pull --rebase --autostash origin main || true

      - name: Verify Anthropic key present (safe)
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            echo "❌ ANTHROPIC_API_KEY is EMPTY. Ensure repo secret 'ANTHROPIC_API_KEY' exists."
            exit 1
          fi
          echo "✅ Key present (len=${#ANTHROPIC_API_KEY})"

      # Normalize to remove accidental \r or \n characters (common copy/paste issue)
      - name: Normalize Anthropic key (strip CR/LF)
        shell: bash
        run: |
          set -euo pipefail
          ANTHROPIC_API_KEY="$(printf '%s' "$ANTHROPIC_API_KEY" | tr -d '\r\n')"
          echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" >> "$GITHUB_ENV"
          echo "✅ Normalized key length=${#ANTHROPIC_API_KEY}"

      # Your requested diagnostic block (prints only length + a few chars, not full key)
      - name: Debug API Key in GitHub Actions (diagnostic + real API call)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== API Key Diagnostics ==="
          echo "Key length: ${#ANTHROPIC_API_KEY}"
          echo "Key starts with sk-ant: $(echo "${ANTHROPIC_API_KEY}" | grep -q '^sk-ant' && echo 'YES' || echo 'NO')"
          echo "First 10 chars: ${ANTHROPIC_API_KEY:0:10}"
          echo "Last 10 chars:  ${ANTHROPIC_API_KEY: -10}"

          HTTP_CODE=$(curl -sS -o /tmp/anthropic_diag.json -w "%{http_code}" \
            https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${ANTHROPIC_API_KEY}" \
            -H "anthropic-version: 2023-06-01" \
            -d '{
              "model": "claude-3-5-haiku-20241022",
              "max_tokens": 5,
              "messages": [{"role":"user","content":"hi"}]
            }')

          echo "Anthropic HTTP status: ${HTTP_CODE}"
          cat /tmp/anthropic_diag.json || true

          if [ "${HTTP_CODE}" != "200" ]; then
            echo "❌ API call failed"
            exit 1
          fi
          echo "✅ API call succeeded"

      - name: Verify Claude Code CLI available
        shell: bash
        run: |
          set -euo pipefail
          which claude
          claude --version | tee /tmp/claude_version.txt
          grep -q "Claude Code" /tmp/claude_version.txt || {
            echo "❌ Claude Code CLI required. Install on runner:"
            echo "   npm uninstall -g claude || true"
            echo "   npm install -g @anthropic-ai/claude-code"
            exit 1
          }

      - name: Ensure jq is installed
        shell: bash
        run: |
          set -euo pipefail
          if command -v jq >/dev/null 2>&1; then
            echo "✅ jq is installed"
            jq --version
            exit 0
          fi

          echo "jq not found. Installing..."
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          elif command -v brew >/dev/null 2>&1; then
            brew install jq
          else
            echo "❌ Could not install jq automatically. Please install jq on the self-hosted runner."
            exit 1
          fi
          jq --version

      - name: Verify App login config present (safe)
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${APP_BASE_URL:-}" ]; then
            echo "❌ APP_BASE_URL is EMPTY. Ensure repo secret 'APP_BASE_URL' exists."
            exit 1
          fi
          if [ -z "${APP_USERNAME:-}" ]; then
            echo "❌ APP_USERNAME is EMPTY. Ensure repo secret 'APP_USERNAME' exists."
            exit 1
          fi
          if [ -z "${APP_PASSWORD:-}" ]; then
            echo "❌ APP_PASSWORD is EMPTY. Ensure repo secret 'APP_PASSWORD' exists."
            exit 1
          fi

          echo "✅ APP_BASE_URL present (len=${#APP_BASE_URL})"
          echo "✅ APP_USERNAME present (len=${#APP_USERNAME})"
          echo "✅ APP_PASSWORD present (len=${#APP_PASSWORD})"

      - name: Write validation input JSON (safe)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .validation/input

          CLAIMS_RAW='${{ github.event.inputs.claims_json }}'
          NAV_RAW='${{ github.event.inputs.navigation_paths_json }}'
          [ -z "${NAV_RAW}" ] && NAV_RAW='[]'

          echo "${CLAIMS_RAW}" | jq -e . >/dev/null
          echo "${NAV_RAW}" | jq -e . >/dev/null

          jq -n \
            --arg feature_name '${{ github.event.inputs.feature_name }}' \
            --argjson claims_to_validate "${CLAIMS_RAW}" \
            --argjson navigation_paths "${NAV_RAW}" \
            --arg app_base_url "${APP_BASE_URL}" \
            --arg app_username "${APP_USERNAME}" \
            --arg app_password "${APP_PASSWORD}" \
            '{
              feature_name: $feature_name,
              claims_to_validate: $claims_to_validate,
              navigation_paths: $navigation_paths,
              app: {
                base_url: $app_base_url,
                username: $app_username,
                password: $app_password
              }
            }' > .validation/input/request.json

          echo "Wrote request.json:"
          # Do NOT print password; redact it for logs
          jq '.app.password="***REDACTED***"' .validation/input/request.json

      - name: Run Interface Validator Agent (PURE, STRICT JSON)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .validation/output

          INPUT_JSON="$(cat .validation/input/request.json)"

          # IMPORTANT:
          # - The heredoc BODY MUST be indented (it is) so YAML doesn't try to parse lines like "SYSTEM (NON-NEGOTIABLE)".
          # - Keep the closing marker at column 1 in bash terms; YAML will still treat it as part of the run block.
          cat > .validation/output/agent_prompt.txt <<'__AGENT_PROMPT__'
          SYSTEM (NON-NEGOTIABLE)

          You are InterfaceValidatorAgent.
          You are NOT a general assistant.

          - Do NOT greet.
          - Do NOT ask questions.
          - Do NOT offer unrelated help.
          - Do NOT execute UI. (Logic-only validation.)
          - Output MUST be exactly one valid JSON object.
          - No markdown.
          - No backticks.
          - No prose.

          If required input is missing or invalid:
          Return:
          { "status": "error", "reason": "invalid_input" }

          TASK

          Given INPUT_JSON containing:
          - feature_name (string)
          - claims_to_validate (array)
          - navigation_paths (array)

          You MUST:
          1. Validate each claim logically (no UI execution)
          2. Produce deterministic validation results
          3. Output strictly valid JSON

          OUTPUT SCHEMA (MANDATORY)

          {
            "status": "ok",
            "feature_name": string,
            "validated_claims": array,
            "summary": string
          }
          __AGENT_PROMPT__

          # Run Claude; capture raw output (Claude sometimes wraps JSON in ```json fences)
          claude -p --output-format text \
            "$(cat .validation/output/agent_prompt.txt)

          INPUT_JSON:
          ${INPUT_JSON}
          " > .validation/output/result_raw.txt

          echo "Saved: .validation/output/result_raw.txt"
          cat .validation/output/result_raw.txt

      # Clean any ```json fences / extra text and write valid JSON only
      - name: Clean JSON Output (strip fences / extract object)
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json, re, pathlib, sys

          raw_path = pathlib.Path(".validation/output/result_raw.txt")
          out_path = pathlib.Path(".validation/output/result.json")

          s = raw_path.read_text(encoding="utf-8", errors="replace").strip()

          # Remove common fenced code blocks
          s = re.sub(r"^```(?:json)?\s*", "", s.strip(), flags=re.IGNORECASE)
          s = re.sub(r"\s*```$", "", s.strip())

          # Extract the first JSON object (best-effort)
          start = s.find("{")
          end = s.rfind("}")
          if start == -1 or end == -1 or end <= start:
            raise SystemExit("Could not find JSON object in output")

          candidate = s[start:end+1].strip()
          obj = json.loads(candidate)  # validate JSON
          out_path.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
          print("✅ Clean JSON saved to", out_path)
          PY

          echo "Cleaned JSON:"
          cat .validation/output/result.json

          # Validate schema quickly
          jq -e 'type=="object"' .validation/output/result.json >/dev/null

          STATUS="$(jq -r '.status // empty' .validation/output/result.json)"

          if [ "$STATUS" = "ok" ]; then
            jq -e '.feature_name and (.validated_claims|type=="array") and .summary' .validation/output/result.json >/dev/null
            echo "✅ Output is valid JSON and matches required OK schema"
          elif [ "$STATUS" = "error" ]; then
            jq -e '.reason' .validation/output/result.json >/dev/null
            echo "✅ Output is valid JSON and matches required ERROR schema"
          else
            echo "❌ Output JSON missing valid status (ok|error)"
            exit 1
          fi

      - name: Upload validation output artifact
        uses: actions/upload-artifact@v4
        with:
          name: interface-validation-${{ github.run_id }}
          path: |
            .validation/output/result.json
            .validation/output/result_raw.txt
            .validation/input/request.json
          if-no-files-found: error
          retention-days: 7

      - name: Commit validation output
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          git add .validation || true

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "Interface validation: ${{ github.event.inputs.feature_name }}"
          git push
