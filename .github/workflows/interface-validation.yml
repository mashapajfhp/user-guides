name: Interface Validation (Pure Agent, Anthropic Safe)

on:
  workflow_dispatch:
    inputs:
      feature_name:
        description: "Feature name to validate"
        required: true
        type: string
      feature_slug:
        description: "Feature slug with underscores for folder paths (e.g., daily_wage_calculator)"
        required: true
        type: string
      folder_path:
        description: "Versioned folder path from n8n (e.g., daily-wage-calculator/v28) - if provided, skips version calculation"
        required: false
        type: string
      next_version:
        description: "Version number from n8n (e.g., v28) - used when folder_path is provided"
        required: false
        type: string
      # NEW: Flattened validation plans array (preferred format)
      plans_json:
        description: "Flattened validation plans array (JSON string) - new format with nav/checks structure"
        required: false
        type: string
      # NEW: Plans metadata (extracted from plans_json for convenience)
      plan_count:
        description: "Number of validation plans"
        required: false
        type: string
      sources:
        description: "Comma-separated list of sources (e.g., 'jira,zendesk')"
        required: false
        type: string
      check_types:
        description: "Comma-separated list of check types (e.g., 'navigation,content_presence,ui_state')"
        required: false
        type: string
      plans_nav_json:
        description: "Extracted navigation paths from plans [{plan_id, nav, breadcrumbs}] (JSON string)"
        required: false
        type: string
      # Intermediate format: issues_to_validate from n8n AI node
      issues_json:
        description: "Issues to validate from n8n AI node (JSON string array of issue objects with validation_steps)"
        required: false
        type: string
      # New format: navigation_paths_from_zendesk (object)
      navigation_paths_from_zendesk_json:
        description: "Navigation paths object from Zendesk {path_id: 'Menu ‚Üí Path'} (JSON string)"
        required: false
        type: string
      # New format: configuration_areas_to_document
      config_areas_json:
        description: "Configuration areas to document from n8n AI node (JSON string array)"
        required: false
        type: string
      # Legacy format: claims_to_validate (kept for backward compatibility)
      claims_json:
        description: "[LEGACY] Claims to validate as string array (JSON string) - use issues_json for new format"
        required: false
        type: string
      # Legacy format: navigation_paths (kept for backward compatibility)
      navigation_paths_json:
        description: "[LEGACY] Navigation paths as string array (JSON string) - use navigation_paths_from_zendesk_json for new format"
        required: false
        type: string
      procedures_json:
        description: "Procedures from Zendesk documentation (JSON string)"
        required: false
        type: string
      # Validation config overrides
      validation_config_json:
        description: "Validation configuration overrides (JSON string)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  validate-interface:
    runs-on: self-hosted
    timeout-minutes: 20
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      APP_BASE_URL: ${{ secrets.APP_BASE_URL }}
      APP_USERNAME: ${{ secrets.APP_USERNAME }}
      APP_PASSWORD: ${{ secrets.APP_PASSWORD }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      # Avoid push/pull conflicts before we create files
      - name: Sync main (safe pull)
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git config rebase.autoStash true
          git pull --rebase --autostash origin main || true

      # Calculate version number for this feature's validation run
      # Uses folder_path from n8n if provided, otherwise calculates locally
      - name: Calculate validation version
        id: version
        run: |
          FEATURE_SLUG="${{ github.event.inputs.feature_slug }}"
          FOLDER_PATH="${{ github.event.inputs.folder_path }}"
          NEXT_VERSION="${{ github.event.inputs.next_version }}"

          # If n8n provided folder_path, use it directly
          if [ -n "$FOLDER_PATH" ]; then
            echo "üì¶ Using folder_path from n8n: ${FOLDER_PATH}"

            # Extract version from folder_path (e.g., daily-wage-calculator/v28 -> v28)
            if [ -n "$NEXT_VERSION" ]; then
              VERSION="${NEXT_VERSION#v}"  # Remove 'v' prefix if present
            else
              VERSION=$(echo "$FOLDER_PATH" | sed 's/.*\/v\([0-9]*\)$/\1/')
            fi

            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "folder_path=$FOLDER_PATH" >> $GITHUB_OUTPUT
            echo "üìä Using n8n version: v$VERSION (folder: ${FOLDER_PATH})"
          else
            # Fallback: calculate version locally
            echo "‚ö†Ô∏è No folder_path from n8n, calculating version locally..."
            VALIDATION_DIR=".validation/output/${FEATURE_SLUG}"

            if [ -d "$VALIDATION_DIR" ]; then
              LATEST_VERSION=$(ls -1d "$VALIDATION_DIR"/v*/ 2>/dev/null | sed 's/.*\/v\([0-9]*\)\//\1/' | sort -n | tail -1)
              if [ -z "$LATEST_VERSION" ]; then
                VERSION=1
              else
                VERSION=$((LATEST_VERSION + 1))
              fi
            else
              VERSION=1
            fi

            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "folder_path=" >> $GITHUB_OUTPUT
            echo "üìä Calculated local version: v$VERSION for ${FEATURE_SLUG}"
          fi

      - name: Verify Anthropic key present (safe)
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            echo "‚ùå ANTHROPIC_API_KEY is EMPTY. Ensure repo secret 'ANTHROPIC_API_KEY' exists."
            exit 1
          fi
          echo "‚úÖ Key present (len=${#ANTHROPIC_API_KEY})"

      # Normalize to remove accidental \r or \n characters (common copy/paste issue)
      - name: Normalize Anthropic key (strip CR/LF)
        shell: bash
        run: |
          set -euo pipefail
          ANTHROPIC_API_KEY="$(printf '%s' "$ANTHROPIC_API_KEY" | tr -d '\r\n')"
          echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" >> "$GITHUB_ENV"
          echo "‚úÖ Normalized key length=${#ANTHROPIC_API_KEY}"

      # Your requested diagnostic block (prints only length + a few chars, not full key)
      - name: Debug API Key in GitHub Actions (diagnostic + real API call)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== API Key Diagnostics ==="
          echo "Key length: ${#ANTHROPIC_API_KEY}"
          echo "Key starts with sk-ant: $(echo "${ANTHROPIC_API_KEY}" | grep -q '^sk-ant' && echo 'YES' || echo 'NO')"
          echo "First 10 chars: ${ANTHROPIC_API_KEY:0:10}"
          echo "Last 10 chars:  ${ANTHROPIC_API_KEY: -10}"

          HTTP_CODE=$(curl -sS -o /tmp/anthropic_diag.json -w "%{http_code}" \
            https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${ANTHROPIC_API_KEY}" \
            -H "anthropic-version: 2023-06-01" \
            -d '{
              "model": "claude-3-5-haiku-20241022",
              "max_tokens": 5,
              "messages": [{"role":"user","content":"hi"}]
            }')

          echo "Anthropic HTTP status: ${HTTP_CODE}"
          cat /tmp/anthropic_diag.json || true

          if [ "${HTTP_CODE}" != "200" ]; then
            echo "‚ùå API call failed"
            exit 1
          fi
          echo "‚úÖ API call succeeded"

      - name: Verify Claude Code CLI available
        shell: bash
        run: |
          set -euo pipefail
          which claude
          claude --version | tee /tmp/claude_version.txt
          grep -q "Claude Code" /tmp/claude_version.txt || {
            echo "‚ùå Claude Code CLI required. Install on runner:"
            echo "   npm uninstall -g claude || true"
            echo "   npm install -g @anthropic-ai/claude-code"
            exit 1
          }

      - name: Ensure jq is installed
        shell: bash
        run: |
          set -euo pipefail
          if command -v jq >/dev/null 2>&1; then
            echo "‚úÖ jq is installed"
            jq --version
            exit 0
          fi

          echo "jq not found. Installing..."
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          elif command -v brew >/dev/null 2>&1; then
            brew install jq
          else
            echo "‚ùå Could not install jq automatically. Please install jq on the self-hosted runner."
            exit 1
          fi
          jq --version

      - name: Verify App login config present (safe)
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${APP_BASE_URL:-}" ]; then
            echo "‚ùå APP_BASE_URL is EMPTY. Ensure repo secret 'APP_BASE_URL' exists."
            exit 1
          fi
          if [ -z "${APP_USERNAME:-}" ]; then
            echo "‚ùå APP_USERNAME is EMPTY. Ensure repo secret 'APP_USERNAME' exists."
            exit 1
          fi
          if [ -z "${APP_PASSWORD:-}" ]; then
            echo "‚ùå APP_PASSWORD is EMPTY. Ensure repo secret 'APP_PASSWORD' exists."
            exit 1
          fi

          echo "‚úÖ APP_BASE_URL present (len=${#APP_BASE_URL})"
          echo "‚úÖ APP_USERNAME present (len=${#APP_USERNAME})"
          echo "‚úÖ APP_PASSWORD present (len=${#APP_PASSWORD})"

      - name: Write validation input JSON (safe)
        id: write_input
        shell: bash
        env:
          # NEW: Flattened plans array (preferred)
          PLANS_JSON: ${{ github.event.inputs.plans_json }}
          # NEW: Plans metadata
          PLAN_COUNT: ${{ github.event.inputs.plan_count }}
          SOURCES: ${{ github.event.inputs.sources }}
          CHECK_TYPES: ${{ github.event.inputs.check_types }}
          PLANS_NAV_JSON: ${{ github.event.inputs.plans_nav_json }}
          # Intermediate format inputs
          ISSUES_JSON: ${{ github.event.inputs.issues_json }}
          NAV_ZENDESK_JSON: ${{ github.event.inputs.navigation_paths_from_zendesk_json }}
          CONFIG_AREAS_JSON: ${{ github.event.inputs.config_areas_json }}
          VALIDATION_CONFIG_JSON: ${{ github.event.inputs.validation_config_json }}
          # Legacy format inputs
          CLAIMS_JSON: ${{ github.event.inputs.claims_json }}
          NAV_JSON: ${{ github.event.inputs.navigation_paths_json }}
          PROCEDURES_JSON: ${{ github.event.inputs.procedures_json }}
          # Common inputs
          FEATURE_NAME: ${{ github.event.inputs.feature_name }}
          FEATURE_SLUG: ${{ github.event.inputs.feature_slug }}
          VERSION: ${{ steps.version.outputs.version }}
          N8N_FOLDER_PATH: ${{ github.event.inputs.folder_path }}
        run: |
          set -euo pipefail

          # Use n8n folder_path if provided, otherwise construct from feature_slug/version
          if [ -n "${N8N_FOLDER_PATH}" ]; then
            # n8n provides folder like "daily-wage-calculator/v28" - use it directly
            VERSIONED_DIR="${N8N_FOLDER_PATH}/validation"
            echo "üì¶ Using n8n folder_path: ${N8N_FOLDER_PATH}"
          else
            # Fallback: construct from feature_slug and calculated version
            VERSIONED_DIR=".validation/output/${FEATURE_SLUG}/v${VERSION}"
          fi

          echo "üìÅ Creating versioned directory: ${VERSIONED_DIR}"
          mkdir -p "${VERSIONED_DIR}/screenshots"
          mkdir -p .validation/input

          # Output versioned_dir for use in subsequent steps
          echo "versioned_dir=${VERSIONED_DIR}" >> $GITHUB_OUTPUT

          # Determine format: plans (new) vs issues (intermediate) vs claims (legacy)
          INPUT_FORMAT="legacy"
          if [ -n "${PLANS_JSON:-}" ] && [ "${PLANS_JSON}" != "null" ] && [ "${PLANS_JSON}" != "[]" ] && [ "${PLANS_JSON}" != "" ]; then
            INPUT_FORMAT="plans"
            echo "üìä Using PLANS format (flattened validation plans array)"
          elif [ -n "${ISSUES_JSON:-}" ] && [ "${ISSUES_JSON}" != "null" ] && [ "${ISSUES_JSON}" != "[]" ] && [ "${ISSUES_JSON}" != "" ]; then
            INPUT_FORMAT="issues"
            echo "üìä Using ISSUES format (issues_to_validate from n8n AI node)"
          else
            echo "üìä Using LEGACY format (claims_to_validate)"
          fi

          # Set defaults for all inputs
          [ -z "${PLANS_JSON:-}" ] && PLANS_JSON='[]'
          [ -z "${PLAN_COUNT:-}" ] && PLAN_COUNT='0'
          [ -z "${SOURCES:-}" ] && SOURCES=''
          [ -z "${CHECK_TYPES:-}" ] && CHECK_TYPES=''
          [ -z "${PLANS_NAV_JSON:-}" ] && PLANS_NAV_JSON='[]'
          [ -z "${ISSUES_JSON:-}" ] && ISSUES_JSON='[]'
          [ -z "${NAV_ZENDESK_JSON:-}" ] && NAV_ZENDESK_JSON='{}'
          [ -z "${CONFIG_AREAS_JSON:-}" ] && CONFIG_AREAS_JSON='[]'
          [ -z "${VALIDATION_CONFIG_JSON:-}" ] && VALIDATION_CONFIG_JSON='{}'
          [ -z "${CLAIMS_JSON:-}" ] && CLAIMS_JSON='[]'
          [ -z "${NAV_JSON:-}" ] && NAV_JSON='[]'
          [ -z "${PROCEDURES_JSON:-}" ] && PROCEDURES_JSON='[]'

          # Validate JSON inputs
          echo "${PLANS_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid plans JSON, using empty array"; PLANS_JSON='[]'; }
          echo "${PLANS_NAV_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid plans nav JSON, using empty array"; PLANS_NAV_JSON='[]'; }
          echo "${ISSUES_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid issues JSON, using empty array"; ISSUES_JSON='[]'; }
          echo "${NAV_ZENDESK_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid nav zendesk JSON, using empty object"; NAV_ZENDESK_JSON='{}'; }
          echo "${CONFIG_AREAS_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid config areas JSON, using empty array"; CONFIG_AREAS_JSON='[]'; }
          echo "${VALIDATION_CONFIG_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid validation config JSON, using empty object"; VALIDATION_CONFIG_JSON='{}'; }
          echo "${CLAIMS_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid claims JSON, using empty array"; CLAIMS_JSON='[]'; }
          echo "${NAV_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid navigation JSON, using empty array"; NAV_JSON='[]'; }
          echo "${PROCEDURES_JSON}" | jq -e . >/dev/null 2>&1 || { echo "‚ö†Ô∏è Invalid procedures JSON, using empty array"; PROCEDURES_JSON='[]'; }

          # Generate clean_feature_name from feature_slug
          CLEAN_FEATURE_NAME=$(echo "${FEATURE_SLUG}" | tr '-' '_')

          # Build the request.json with all format fields
          jq -n \
            --arg feature_name "${FEATURE_NAME}" \
            --arg clean_feature_name "${CLEAN_FEATURE_NAME}" \
            --arg input_format "${INPUT_FORMAT}" \
            --argjson validation_plans "${PLANS_JSON}" \
            --arg plan_count "${PLAN_COUNT}" \
            --arg sources "${SOURCES}" \
            --arg check_types "${CHECK_TYPES}" \
            --argjson plans_navigation "${PLANS_NAV_JSON}" \
            --argjson issues_to_validate "${ISSUES_JSON}" \
            --argjson navigation_paths_from_zendesk "${NAV_ZENDESK_JSON}" \
            --argjson configuration_areas_to_document "${CONFIG_AREAS_JSON}" \
            --argjson validation_config_overrides "${VALIDATION_CONFIG_JSON}" \
            --argjson claims_to_validate "${CLAIMS_JSON}" \
            --argjson navigation_paths "${NAV_JSON}" \
            --argjson procedures "${PROCEDURES_JSON}" \
            --arg app_base_url "${APP_BASE_URL}" \
            --arg app_username "${APP_USERNAME}" \
            --arg app_password "${APP_PASSWORD}" \
            --arg screenshots_dir "${VERSIONED_DIR}/screenshots" \
            --arg reports_dir "${VERSIONED_DIR}" \
            --arg evidence_file "${VERSIONED_DIR}/evidence.json" \
            --arg summary_file "${VERSIONED_DIR}/validation-summary.md" \
            '{
              feature_name: $feature_name,
              clean_feature_name: $clean_feature_name,
              input_format: $input_format,
              # NEW: Flattened validation plans array
              validation_plans: $validation_plans,
              # NEW: Plans metadata (extracted for convenience)
              plan_count: ($plan_count | tonumber),
              sources: $sources,
              check_types: $check_types,
              plans_navigation: $plans_navigation,
              # Intermediate format fields
              issues_to_validate: $issues_to_validate,
              navigation_paths_from_zendesk: $navigation_paths_from_zendesk,
              configuration_areas_to_document: $configuration_areas_to_document,
              # Legacy format fields
              claims_to_validate: $claims_to_validate,
              navigation_paths: $navigation_paths,
              procedures: $procedures,
              # Validation config (merged with defaults)
              validation_config: ({
                base_url: $app_base_url,
                login_required: true,
                required_role: "Superadmin",
                max_attempts_per_validation: 2,
                screenshot_on_each_step: true,
                timeout_ms: 30000,
                wait_after_navigation_ms: 2000
              } * $validation_config_overrides),
              # App credentials
              app: {
                base_url: $app_base_url,
                username: $app_username,
                password: $app_password
              },
              # Output configuration (required by interface-validator)
              output_configuration: {
                screenshots_dir: $screenshots_dir,
                reports_dir: $reports_dir,
                evidence_file: $evidence_file,
                summary_file: $summary_file
              }
            }' > .validation/input/request.json

          echo "Wrote request.json:"
          # Do NOT print password; redact it for logs
          jq '.app.password="***REDACTED***"' .validation/input/request.json

      - name: Setup Node (for Playwright)
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright deps
        shell: bash
        run: |
          set -euo pipefail
          npm ci
          npx playwright install --with-deps

      # ============================================================================
      # PRIMARY VALIDATION: Playwright Runner (run-validation.mjs)
      # - Performs ACTUAL UI validation using cognitive walkthrough methodology
      # - Produces pw_result.json with real browser-based validation results
      # - This is the authoritative validation output used by n8n
      # ============================================================================
      - name: Run Playwright validation (UI execution)
        shell: bash
        timeout-minutes: 10
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
          PLAYWRIGHT_GOTO_TIMEOUT_MS: "30000"
          PLAYWRIGHT_STEP_TIMEOUT_MS: "10000"
          # Enable DEBUG_EXPLORER to analyze accordion detection
          # Set to "1" to enable detailed logging and debug artifacts
          DEBUG_EXPLORER: "1"
        run: |
          set -euo pipefail
          echo "üì∏ Screenshots will be saved to: ${VERSIONED_DIR}/screenshots/"
          echo "üîç DEBUG_EXPLORER=${DEBUG_EXPLORER:-0} (set to 1 for detailed accordion analysis)"
          node scripts/playwright/run-validation.mjs \
            --input .validation/input/request.json \
            --out "${VERSIONED_DIR}/pw_result.json" \
            --screenshots "${VERSIONED_DIR}/screenshots"

      - name: Clean JSON Output (Playwright) - ensure valid JSON file exists
        shell: bash
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
        run: |
          set -euo pipefail
          test -f "${VERSIONED_DIR}/pw_result.json"
          jq -e . "${VERSIONED_DIR}/pw_result.json" >/dev/null
          echo "‚úÖ pw_result.json is valid JSON in ${VERSIONED_DIR}"

      # Copy pw_result.json to root location for n8n to fetch via static URL
      - name: Copy pw_result.json to root output
        shell: bash
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
        run: |
          set -euo pipefail
          ROOT_OUTPUT=".validation/output"
          mkdir -p "${ROOT_OUTPUT}"
          cp "${VERSIONED_DIR}/pw_result.json" "${ROOT_OUTPUT}/pw_result.json"
          echo "‚úÖ Copied pw_result.json to ${ROOT_OUTPUT}/pw_result.json (for n8n static URL)"

      # ============================================================================
      # SECONDARY: Logic-Only Validation (Placeholder for future agent integration)
      # - Currently runs a generic Claude prompt for LOGIC-ONLY validation
      # - Does NOT invoke agents/interface-validator.md agent
      # - Does NOT perform actual UI automation
      # - Produces result.json for schema validation purposes
      # - TODO: Replace with proper interface-validator.md agent invocation
      # See: docs/PAYLOAD-ALIGNMENT-ANALYSIS.md for architecture details
      # ============================================================================
      - name: Run Interface Validator Agent (PURE, STRICT JSON)
        shell: bash
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
          # VALIDATOR_* env vars for future interface-validator.md integration
          VALIDATOR_SCREENSHOTS_DIR: ${{ steps.write_input.outputs.versioned_dir }}/screenshots
          VALIDATOR_REPORTS_DIR: ${{ steps.write_input.outputs.versioned_dir }}
          VALIDATOR_EVIDENCE_FILE: ${{ steps.write_input.outputs.versioned_dir }}/evidence.json
          VALIDATOR_SUMMARY_FILE: ${{ steps.write_input.outputs.versioned_dir }}/validation-summary.md
        run: |
          set -euo pipefail
          mkdir -p "${VERSIONED_DIR}"

          INPUT_JSON="$(cat .validation/input/request.json)"

          # IMPORTANT:
          # - The heredoc BODY MUST be indented (it is) so YAML doesn't try to parse lines like "SYSTEM (NON-NEGOTIABLE)".
          # - Keep the closing marker at column 1 in bash terms; YAML will still treat it as part of the run block.
          cat > "${VERSIONED_DIR}/agent_prompt.txt" <<'__AGENT_PROMPT__'
          SYSTEM (NON-NEGOTIABLE)

          You are InterfaceValidatorAgent.
          You are NOT a general assistant.

          - Do NOT greet.
          - Do NOT ask questions.
          - Do NOT offer unrelated help.
          - Do NOT execute UI. (Logic-only validation.)
          - Output MUST be exactly one valid JSON object.
          - No markdown.
          - No backticks.
          - No prose.

          If required input is missing or invalid:
          Return:
          { "status": "error", "reason": "invalid_input" }

          TASK

          Given INPUT_JSON containing:
          - feature_name (string)
          - claims_to_validate (array)
          - navigation_paths (array)

          You MUST:
          1. Validate each claim logically (no UI execution)
          2. Produce deterministic validation results
          3. Output strictly valid JSON

          OUTPUT SCHEMA (MANDATORY)

          {
            "status": "ok",
            "feature_name": string,
            "validated_claims": array,
            "summary": string
          }
          __AGENT_PROMPT__

          # Run Claude; capture raw output (Claude sometimes wraps JSON in ```json fences)
          claude -p --output-format text \
            "$(cat "${VERSIONED_DIR}/agent_prompt.txt")

          INPUT_JSON:
          ${INPUT_JSON}
          " > "${VERSIONED_DIR}/result_raw.txt"

          echo "Saved: ${VERSIONED_DIR}/result_raw.txt"
          cat "${VERSIONED_DIR}/result_raw.txt"

      # Clean any ```json fences / extra text and write valid JSON only
      - name: Clean JSON Output (strip fences / extract object)
        shell: bash
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
        run: |
          set -euo pipefail

          python3 - "${VERSIONED_DIR}" <<'PY'
          import json, re, pathlib, sys

          versioned_dir = pathlib.Path(sys.argv[1])
          raw_path = versioned_dir / "result_raw.txt"
          out_path = versioned_dir / "result.json"

          s = raw_path.read_text(encoding="utf-8", errors="replace").strip()

          # Remove common fenced code blocks
          s = re.sub(r"^```(?:json)?\s*", "", s.strip(), flags=re.IGNORECASE)
          s = re.sub(r"\s*```$", "", s.strip())

          # Extract the first JSON object (best-effort)
          start = s.find("{")
          end = s.rfind("}")
          if start == -1 or end == -1 or end <= start:
            raise SystemExit("Could not find JSON object in output")

          candidate = s[start:end+1].strip()
          obj = json.loads(candidate)  # validate JSON
          out_path.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
          print("‚úÖ Clean JSON saved to", out_path)
          PY

          echo "Cleaned JSON:"
          cat "${VERSIONED_DIR}/result.json"

          # Validate schema quickly
          jq -e 'type=="object"' "${VERSIONED_DIR}/result.json" >/dev/null

          STATUS="$(jq -r '.status // empty' "${VERSIONED_DIR}/result.json")"

          if [ "$STATUS" = "ok" ]; then
            jq -e '.feature_name and (.validated_claims|type=="array") and .summary' "${VERSIONED_DIR}/result.json" >/dev/null
            echo "‚úÖ Output is valid JSON and matches required OK schema"
          elif [ "$STATUS" = "error" ]; then
            jq -e '.reason' "${VERSIONED_DIR}/result.json" >/dev/null
            echo "‚úÖ Output is valid JSON and matches required ERROR schema"
          else
            echo "‚ùå Output JSON missing valid status (ok|error)"
            exit 1
          fi

      - name: Prepare artifact paths
        id: artifact_paths
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
        run: |
          echo "versioned_dir=${VERSIONED_DIR}" >> $GITHUB_OUTPUT
          # Create artifact path list dynamically
          echo "üì¶ Validation outputs at: ${VERSIONED_DIR}"

      - name: Upload validation output artifact
        uses: actions/upload-artifact@v4
        with:
          name: interface-validation-${{ github.event.inputs.feature_slug }}-v${{ steps.version.outputs.version }}-${{ github.run_id }}
          path: |
            ${{ steps.write_input.outputs.versioned_dir }}/result.json
            ${{ steps.write_input.outputs.versioned_dir }}/result_raw.txt
            ${{ steps.write_input.outputs.versioned_dir }}/pw_result.json
            ${{ steps.write_input.outputs.versioned_dir }}/screenshots/**
            .validation/input/request.json
          if-no-files-found: error
          retention-days: 7

      # ============================================================================
      # PERSIST RUN-SCOPED INPUT AND OUTPUT
      # Store executed input + output together for full reproducibility
      # ============================================================================
      - name: Persist run-scoped input and output
        shell: bash
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
        run: |
          set -euo pipefail

          RUN_ID="${GITHUB_RUN_ID:-local}"
          BASE_PATH="${VERSIONED_DIR}/run_${RUN_ID}"

          echo "üì¶ Creating run-scoped folder: ${BASE_PATH}"

          mkdir -p "$BASE_PATH/input"
          mkdir -p "$BASE_PATH/output"

          # Persist executed input
          cp .validation/input/request.json "$BASE_PATH/input/request.json"
          echo "‚úÖ Copied input to: $BASE_PATH/input/request.json"

          # Persist output
          if [ -f "${VERSIONED_DIR}/pw_result.json" ]; then
            cp "${VERSIONED_DIR}/pw_result.json" "$BASE_PATH/output/pw_result.json"
            echo "‚úÖ Copied output to: $BASE_PATH/output/pw_result.json"
          else
            echo "‚ö†Ô∏è pw_result.json not found at ${VERSIONED_DIR}/pw_result.json"
          fi

          echo "üìÅ Run-scoped folder structure:"
          find "$BASE_PATH" -type f | head -20

      - name: Commit validation output
        shell: bash
        env:
          VERSIONED_DIR: ${{ steps.write_input.outputs.versioned_dir }}
          VERSION: ${{ steps.version.outputs.version }}
          N8N_FOLDER_PATH: ${{ github.event.inputs.folder_path }}
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          RUN_ID="${GITHUB_RUN_ID:-local}"

          # Always add root pw_result.json for n8n static URL access
          git add .validation/output/pw_result.json || true

          # Add validation outputs - use n8n folder_path if provided
          if [ -n "${N8N_FOLDER_PATH}" ]; then
            # n8n folder structure - add the entire version folder
            git add "${N8N_FOLDER_PATH}" || true
          else
            # Fallback: old .validation structure
            git add .validation || true
          fi

          # Add run-scoped folder explicitly
          git add "${VERSIONED_DIR}/run_${RUN_ID}" || true

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git commit -m "Interface validation v${VERSION}: ${{ github.event.inputs.feature_name }} (run ${RUN_ID})"
          git push
          echo "‚úÖ Committed validation outputs to: ${VERSIONED_DIR}/"
          echo "‚úÖ Run-scoped input/output at: ${VERSIONED_DIR}/run_${RUN_ID}/"
          echo "‚úÖ Root pw_result.json updated at .validation/output/pw_result.json"
